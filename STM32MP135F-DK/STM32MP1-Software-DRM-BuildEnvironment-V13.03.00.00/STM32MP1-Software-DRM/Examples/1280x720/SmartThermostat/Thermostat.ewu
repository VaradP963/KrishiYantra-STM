$version 13.00

// Device Class
note group GlobalsNote
{
  attr Bounds = <270,380,520,530>;
}

// Constants
note group ConstantsNote
{
  attr Bounds = <20,380,260,530>;
}

// Resources
note group Note
{
  attr Bounds = <530,0,1180,220>;
}

$rect <40,150,280,190>
$output false
autoobject WidgetSet::ToggleButtonConfig SwingSwitchConfig
{
  preset FaceOnFrameActive = 3;
  preset FaceOnFrameFocused = 1;
  preset FaceOnFrameDisabled = 1;
  preset FaceOnFrameDefault = 1;
  preset FaceOnBitmapActive = Thermostat::SwingSwitch;
  preset FaceOnBitmapFocused = Thermostat::SwingSwitch;
  preset FaceOnBitmapDisabled = Thermostat::SwingSwitch;
  preset FaceOnBitmapDefault = Thermostat::SwingSwitch;
  preset FaceOffFrameActive = 2;
  preset FaceOffFrameFocused = 0;
  preset FaceOffFrameDisabled = 0;
  preset FaceOffFrameDefault = 0;
  preset FaceOffBitmapActive = Thermostat::SwingSwitch;
  preset FaceOffBitmapFocused = Thermostat::SwingSwitch;
  preset FaceOffBitmapDisabled = Thermostat::SwingSwitch;
  preset FaceOffBitmapDefault = Thermostat::SwingSwitch;
  preset WidgetMaxSize = <113,66>;
  preset WidgetMinSize = <113,66>;
}

$rect <290,150,490,190>
$output false
resource Resources::Bitmap SwingSwitch
{
  attr bitmapfile FileName = .\Res\SwingSwitch.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize = <113,66>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <290,190,490,230>
$output false
resource Resources::Bitmap ButtonDay
{
  attr bitmapfile FileName = .\Res\ButtonDay.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize = <66,66>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <290,230,490,270>
$output false
resource Resources::Bitmap ButtonNight
{
  attr bitmapfile FileName = .\Res\ButtonNight.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize = <66,66>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <290,270,490,310>
$output false
resource Resources::Bitmap ButtonVacation
{
  attr bitmapfile FileName = .\Res\ButtonVacation.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize = <66,66>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <40,190,280,230>
$output false
autoobject WidgetSet::RadioButtonConfig RadioButtonDayConfig
{
  preset LabelOnColorActive = #FFFFFFFF;
  preset LabelOnColorFocused = #FFFFFFFF;
  preset LabelOnColorDefault = #FFFFFFFF;
  preset LabelOffColorActive = #FFFFFFFF;
  preset LabelOffColorFocused = #FFFFFFFF;
  preset LabelOffColorDefault = #FFFFFFFF;
  preset LabelMarginLeft = 80;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = Thermostat::FontL;
  preset LabelOffFont = Thermostat::FontL;
  preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop];
  preset FaceOnFrameActive = 1;
  preset FaceOnFrameFocused = 1;
  preset FaceOnFrameDisabled = 1;
  preset FaceOnFrameDefault = 1;
  preset FaceOnBitmapActive = Thermostat::ButtonDay;
  preset FaceOnBitmapFocused = Thermostat::ButtonDay;
  preset FaceOnBitmapDisabled = Thermostat::ButtonDay;
  preset FaceOnBitmapDefault = Thermostat::ButtonDay;
  preset FaceOffFrameActive = 0;
  preset FaceOffFrameFocused = 0;
  preset FaceOffFrameDisabled = 0;
  preset FaceOffFrameDefault = 0;
  preset FaceOffBitmapActive = Thermostat::ButtonDay;
  preset FaceOffBitmapFocused = Thermostat::ButtonDay;
  preset FaceOffBitmapDisabled = Thermostat::ButtonDay;
  preset FaceOffBitmapDefault = Thermostat::ButtonDay;
  preset WidgetMaxSize = <660,66>;
  preset WidgetMinSize = <66,66>;
}

$rect <40,230,280,270>
$output false
autoobject WidgetSet::RadioButtonConfig RadioButtonNightConfig
{
  preset LabelOnColorActive = #FFFFFFFF;
  preset LabelOnColorFocused = #FFFFFFFF;
  preset LabelOnColorDefault = #FFFFFFFF;
  preset LabelOffColorActive = #FFFFFFFF;
  preset LabelOffColorFocused = #FFFFFFFF;
  preset LabelOffColorDefault = #FFFFFFFF;
  preset LabelMarginLeft = 80;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = Thermostat::FontL;
  preset LabelOffFont = Thermostat::FontL;
  preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop];
  preset FaceOnFrameActive = 1;
  preset FaceOnFrameFocused = 1;
  preset FaceOnFrameDisabled = 1;
  preset FaceOnFrameDefault = 1;
  preset FaceOnBitmapActive = Thermostat::ButtonNight;
  preset FaceOnBitmapFocused = Thermostat::ButtonNight;
  preset FaceOnBitmapDisabled = Thermostat::ButtonNight;
  preset FaceOnBitmapDefault = Thermostat::ButtonNight;
  preset FaceOffFrameActive = 0;
  preset FaceOffFrameFocused = 0;
  preset FaceOffFrameDisabled = 0;
  preset FaceOffFrameDefault = 0;
  preset FaceOffBitmapActive = Thermostat::ButtonNight;
  preset FaceOffBitmapFocused = Thermostat::ButtonNight;
  preset FaceOffBitmapDisabled = Thermostat::ButtonNight;
  preset FaceOffBitmapDefault = Thermostat::ButtonNight;
  preset WidgetMaxSize = <660,66>;
  preset WidgetMinSize = <66,66>;
}

$rect <40,270,280,310>
$output false
autoobject WidgetSet::RadioButtonConfig RadioButtonVacationConfig
{
  preset LabelOnColorActive = #FFFFFFFF;
  preset LabelOnColorFocused = #FFFFFFFF;
  preset LabelOnColorDefault = #FFFFFFFF;
  preset LabelOffColorActive = #FFFFFFFF;
  preset LabelOffColorFocused = #FFFFFFFF;
  preset LabelOffColorDefault = #FFFFFFFF;
  preset LabelMarginLeft = 80;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = Thermostat::FontL;
  preset LabelOffFont = Thermostat::FontL;
  preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop];
  preset FaceOnFrameActive = 1;
  preset FaceOnFrameFocused = 1;
  preset FaceOnFrameDisabled = 1;
  preset FaceOnFrameDefault = 1;
  preset FaceOnBitmapActive = Thermostat::ButtonVacation;
  preset FaceOnBitmapFocused = Thermostat::ButtonVacation;
  preset FaceOnBitmapDisabled = Thermostat::ButtonVacation;
  preset FaceOnBitmapDefault = Thermostat::ButtonVacation;
  preset FaceOffFrameActive = 0;
  preset FaceOffFrameFocused = 0;
  preset FaceOffFrameDisabled = 0;
  preset FaceOffFrameDefault = 0;
  preset FaceOffBitmapActive = Thermostat::ButtonVacation;
  preset FaceOffBitmapFocused = Thermostat::ButtonVacation;
  preset FaceOffBitmapDisabled = Thermostat::ButtonVacation;
  preset FaceOffBitmapDefault = Thermostat::ButtonVacation;
  preset WidgetMaxSize = <660,66>;
  preset WidgetMinSize = <66,66>;
}

// Font resources used for the different widgets. If you want to change the fonts \
// within your project, just create a variant of these font resources and define \
// the attributes of the font resources according your design ideas.
$rect <960,80,1160,120>
$output false
resource Resources::Font FontL
{
  attr fontname FontName = Roboto Light;
  attr fontheight Height = 54;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontheightmode HeightMode = Compatible;
  attr fontrowdistance RowDistance;
}

$rect <290,310,490,350>
$output false
resource Resources::Bitmap VertBar
{
  attr bitmapfile FileName = .\Res\VertBar.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize = <30,330>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <40,310,280,350>
$output false
autoobject WidgetSet::VerticalSliderConfig VerticalSliderConfig
{
  preset TrackAboveFrameActive = 0;
  preset TrackAboveFrameFocused = 0;
  preset TrackAboveFrameDisabled = 0;
  preset TrackAboveFrameDefault = 0;
  preset TrackAboveBitmapActive = Thermostat::VertBar;
  preset TrackAboveBitmapFocused = Thermostat::VertBar;
  preset TrackAboveBitmapDisabled = Thermostat::VertBar;
  preset TrackAboveBitmapDefault = Thermostat::VertBar;
  preset TrackBelowFrameActive = 1;
  preset TrackBelowFrameFocused = 1;
  preset TrackBelowFrameDisabled = 1;
  preset TrackBelowFrameDefault = 1;
  preset TrackBelowBitmapActive = Thermostat::VertBar;
  preset TrackBelowBitmapFocused = Thermostat::VertBar;
  preset TrackBelowBitmapDisabled = Thermostat::VertBar;
  preset TrackBelowBitmapDefault = Thermostat::VertBar;
  preset WidgetMaxSize = <30,330>;
  preset WidgetMinSize = <30,330>;
}

$rect <290,420,490,460>
$output false
class DeviceClass : Templates::DeviceClass
{
  // The property 'ActualTemp' represents the current temperature value in 1/10 degrees. \
  // In a real system this value is measured and provided by the underlying system.
  $rect <220,60,420,100>
  property int32 ActualTemp = 155;

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of the property 'ActualTemp'.
  $rect <20,60,220,100>
  $output true
  method void UpdateActualTemp( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure ActualTemp )
    {
      // Remember the new value in the internal memory of the property.
      pure ActualTemp = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^ActualTemp;
    }
  }

  // Interface to read and modify a device setting or state value
  note group Note1
  {
    attr Bounds = <10,10,640,280>;
  }

  // The property 'NominalTemp' represents the current temperature set value in 1/10 \
  // degrees. This value is set by the GUI application and forwarded to the underlying \
  // system.
  $rect <220,100,420,140>
  property int32 NominalTemp = 215;

  $rect <420,100,620,140>
  onset NominalTemp
  {
    // The property doesn't change -> nothing to do.
    if ( pure NominalTemp == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure NominalTemp = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^NominalTemp;
  }

  $rect <220,140,420,180>
  property int32 FanSpeed = 30;

  $rect <420,140,620,180>
  onset FanSpeed
  {
    // The property doesn't change -> nothing to do.
    if ( pure FanSpeed == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure FanSpeed = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^FanSpeed;
  }

  $rect <220,180,420,220>
  property bool SwingMode = false;

  $rect <420,180,620,220>
  onset SwingMode
  {
    // The property doesn't change -> nothing to do.
    if ( pure SwingMode == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure SwingMode = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^SwingMode;
  }

  $rect <20,340,220,380>
  slot ChangeActualTemp
  {
    /* this is just a simulation of heating / cooling */
    var int32 temp = ActualTemp;

    if ( temp < NominalTemp )
      temp = temp + 1;
    else if ( temp > NominalTemp )
      temp = temp - 1;

    UpdateActualTemp( temp );

  }

  $rect <220,340,420,380>
  object Core::Timer ChangeTempTimer
  {
    preset OnTrigger = ChangeActualTemp;
    preset Period = 150;
    preset Enabled = true;
  }

  // Animate Temperature
  note group TemperatureNote
  {
    attr Bounds = <10,290,440,400>;
  }

  // This is used to set the actual temperature closer and closer to the nominal \
  // - just for demonstration purposes.
  note legend TempNote
  {
    attr Bounds = <450,290,750,400>;
  }

  $rect <220,220,420,260>
  property int32 SettingNo = 0;

  $rect <420,220,620,260>
  onset SettingNo
  {
    /* limit to three settings */
    if ( value > 2 )
      value = 2;
    if ( value < 0 )
      value = 0;


    // The property doesn't change -> nothing to do.
    if ( pure SettingNo == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure SettingNo = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^SettingNo;
  }
}

$rect <290,460,490,500>
autoobject Thermostat::DeviceClass Device;

$rect <550,40,750,80>
$output false
resource Resources::Bitmap Wheels
{
  attr bitmapfile FileName = .\Res\Wheels.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize = <510,510>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <550,80,750,120>
$output false
resource Resources::Bitmap Controller
{
  attr bitmapfile FileName = .\Res\Controller.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <290,40,490,80>
$output false
class TemperatureController : Core::Group
{
  $rect <10,540,210,580>
  inherited property Bounds = <0,0,510,510>;

  $rect <10,620,210,660>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /* determine center point */
    var int32 cX = aSize.x / 2;
    var int32 cY = aSize.y / 2;

    /* arrange the minmax indicator */
    DeltaTempView.Bounds = rect( <0,0>, aSize );
    DeltaTempView.Offset = point( cX, cY );

  }

  $rect <10,580,210,620>
  inherited method UpdateViewState()
  {
    /* Always invoke the inherited method */
    super( aState );

    var int32 alpha = 0;
    var int32 actual = pure ActualValue;
    var float actAngle = 0.0;
    var int32 nominal = pure NominalValue;
    var float nomAngle = 0.0;

    /* ensure limits of the temperature values */
    if ( actual < pure MinValue )
      actual = pure MinValue;
    if ( actual > pure MaxValue )
      actual = pure MaxValue;
    if ( nominal < pure MinValue )
      nominal = pure MinValue;
    if ( nominal > pure MaxValue )
      nominal = pure MaxValue;

    /* calculate angles for actual and nominal temperature */
    if ( pure MaxValue > pure MinValue)
    {
      actAngle = 135.0 - (float)( actual - pure MinValue ) * 270.0 / (float)( pure MaxValue - pure MinValue ); 
      nomAngle = 135.0 - (float)( nominal - pure MinValue ) * 270.0 / (float)( pure MaxValue - pure MinValue ); 
    }

    /* place the needle at nominal temperature */
    Needle.RotateAndScale( Foreground.Bounds.center, nomAngle, 1.0, 1.0 );

    var int32 inner = 138;
    var int32 outer = 153;

    /* calculate the delta temperature indicator */
    if (( pure MaxValue > pure MinValue) && ( actual != nominal ))
    {
      /* draw line for actAngle and an arc between actAngle and nomAngle */
      DeltaTempPath.InitSubPath( 0, 84 );
      DeltaTempPath.Rotate( -actAngle -90.0 );
      DeltaTempPath.Begin( 0, inner, 0 );
      DeltaTempPath.AddLine( 0, outer, 0 );
      DeltaTempPath.AddArc( 0, 0, 0, outer, outer, 0, -nomAngle + actAngle, 80 );
      DeltaTempPath.Rotate( actAngle + 90.0 );
    }
    else
    {
      /* clear the path */
      DeltaTempPath.InitSubPath( 0, 84 );
    }

    /* colorize the delta temperature indicator and the heat/cool symbol */
    if ( actual < nominal )
    {
      /* heating */
      Symbol.FrameNumber = 0;
      Symbol.Color = Thermostat::ColorHot;
      DeltaTempView.Color = Thermostat::ColorHot;
      alpha = ( nominal - actual ) * 10;
    }
    else if ( actual > nominal )
    {
      /* cooling */
      Symbol.FrameNumber = 1;
      Symbol.Color = Thermostat::ColorCold;
      DeltaTempView.Color = Thermostat::ColorCold;
      alpha = ( actual - nominal ) * 10;
    }
    if ( alpha > 255 )
      alpha = 255;
    Symbol.Opacity = alpha;

    /* format the string for the digital temperature display */
    ActualText.String = string( actual / 10 ) + "." + string( actual % 10 ) + "°C";
    NominalText.String = string( nominal / 10 ) + "." + string( nominal % 10 ) + "°C";

    /* the color of the actual temperature text should correspond to the temperature */
    alpha = ( actual - pure MinValue ) * 255 / ( pure MaxValue - pure MinValue );
    var color hot = Thermostat::ColorHot * alpha;
    var color cold = Thermostat::ColorCold * (uint8)( 255 - alpha );
    ActualText.Color = hot + cold;

  }

  // This is a rotate gesture handler.
  $rect <20,20,160,60>
  object Core::RotateTouchHandler RotateTouchHandler
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop];
    preset Bounds = <0,0,510,510>;
    preset OnRotate = onRotateSlot;
    preset OnEnd = onEndSlot;
    preset OnStart = onStartSlot;
  }

  $rect <20,20,160,60>
  object Views::Image Wheel
  {
    preset Bounds = <0,0,510,510>;
    preset Bitmap = Thermostat::Wheels;
  }

  $rect <20,20,160,60>
  object Views::Image Foreground
  {
    preset Bounds = <15,15,495,495>;
    preset Bitmap = Thermostat::Controller;
  }

  $rect <20,20,160,60>
  object Views::WarpImage Needle
  {
    preset Point4 = <348,130>;
    preset Point3 = <394,178>;
    preset Point2 = <427,147>;
    preset Point1 = <379,99>;
    preset SourceAnchor = <15,132>;
    preset Bitmap = Thermostat::Needle;
  }

  // The property 'NominalValue' represents the current temperature set value in \
  // 1/10 degrees. 
  $rect <530,130,730,170>
  property int32 NominalValue = 300;

  $rect <730,130,930,170>
  onset NominalValue
  {
    /* check if the given value differs from the current value */
    if ( pure NominalValue == value )
      return;

    /* store the new value */
    pure NominalValue = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  // The property 'ActualValue' represents the current temperature value in 1/10 \
  // degrees.
  $rect <530,90,730,130>
  property int32 ActualValue = 150;

  $rect <730,90,930,130>
  onset ActualValue
  {
    /* check if the given value differs from the current value */
    if ( pure ActualValue == value )
      return;

    /* store the new value */
    pure ActualValue = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <930,210,1130,250>
  slot outletNominalSlot
  {
    /* update the current state of the widget */
    if ( OutletNominal != null )
      NominalValue = OutletNominal^;
  }

  $rect <730,210,930,250>
  onset OutletNominal
  {
    /* check if the new outlet differs from the currently used outlet */
    if ( pure OutletNominal == value )
      return;

    /* detach from the previous outlet */
    if ( pure OutletNominal != null )
      detachobserver outletNominalSlot, pure OutletNominal;

    /* store the new outlet */
    pure OutletNominal = value;

    /* ... and attach to the new one */
    if ( value != null )
      attachobserver outletNominalSlot, value;

    /* finally, update the current state of the widget by posting a signal to the outlet slot */
    if ( value != null )
      postsignal outletNominalSlot;
  }

  // The property 'OutletNominal' provides an interface for the Controller-View model. \
  // In the Controller-View model, the widgets (views) and the application logic \
  // (controllers) are always kept apart. An automatism behind this model ensures, \
  // that widgets are notified automatically as soon as the affected controller has \
  // changed its state. On the other hand, user interactions on a widget cause the \
  // affected controller to execute the application logic. Usually, a controller \
  // is a simple Chora object containg several properties and the implementation \
  // of onget/onset method.
  // By assigning a property reference, Outlet establishes a connection between the \
  // widget and the controller object, the affected property belongs to. After this, \
  // the widget is able to read and modify the referred property in response to the \
  // user interactions. It is also able to adapt the widget appearance, if the value \
  // of the referred property has been modified by another widget or by the application \
  // logic itself.
  $rect <530,210,730,250>
  property ^int32 OutletNominal = null;

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <930,170,1130,210>
  slot outletCurrentSlot
  {
    /* update the current state of the widget */
    if ( OutletActual != null )
      ActualValue = OutletActual^;
  }

  $rect <730,170,930,210>
  onset OutletActual
  {
    /* check if the new outlet differs from the currently used outlet */
    if ( pure OutletActual == value )
      return;

    /* detach from the previous outlet */
    if ( pure OutletActual != null )
      detachobserver outletCurrentSlot, pure OutletActual;

    /* store the new outlet */
    pure OutletActual = value;

    /* ... and attach to the new one */
    if ( value != null )
      attachobserver outletCurrentSlot, value;

    /* finally, update the current state of the widget by posting a signal to the outlet slot */
    if ( value != null )
      postsignal outletCurrentSlot;
  }

  // The property 'OutletActual' provides an interface for the Controller-View model. \
  // In the Controller-View model, the widgets (views) and the application logic \
  // (controllers) are always kept apart. An automatism behind this model ensures, \
  // that widgets are notified automatically as soon as the affected controller has \
  // changed its state. On the other hand, user interactions on a widget cause the \
  // affected controller to execute the application logic. Usually, a controller \
  // is a simple Chora object containg several properties and the implementation \
  // of onget/onset method.
  // By assigning a property reference, Outlet establishes a connection between the \
  // widget and the controller object, the affected property belongs to. After this, \
  // the widget is able to read and modify the referred property in response to the \
  // user interactions. It is also able to adapt the widget appearance, if the value \
  // of the referred property has been modified by another widget or by the application \
  // logic itself.
  $rect <530,170,730,210>
  property ^int32 OutletActual = null;

  // The property 'MaxValue' defines the maximum value of the temperature control \
  // in 1/10 degrees.
  $rect <530,50,730,90>
  property int32 MaxValue = 400;

  $rect <730,50,930,90>
  onset MaxValue
  {
    /* check if the given value differs from the current value */
    if ( pure MaxValue == value )
      return;

    /* store the new value */
    pure MaxValue = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  // The property 'MinValue' defines the minimum value of the temperature control \
  // in 1/10 degrees.
  $rect <530,10,730,50>
  property int32 MinValue = 100;

  $rect <730,10,930,50>
  onset MinValue
  {
    /* check if the given value differs from the current value */
    if ( pure MinValue == value )
      return;

    /* store the new value */
    pure MinValue = value;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  $rect <530,350,730,390>
  slot onStartSlot
  {
    /* user interaction begins */
    InvalidateViewState();
    startValue = NominalValue;

    /* nominal text has to be shown */
    NominalText.Opacity = 0xFF;
    ActualText.Opacity  = 0x00;
    FadeTextEffect.Enabled = false;


  }

  $rect <530,388,730,428>
  slot onRotateSlot
  {
    var int32 temp = 0;
    var int32 delta = 0;

    /* ensure that the current set value and the given minimum and maximum values are valid */
    if (( pure MaxValue > pure MinValue) && ( pure NominalValue >= pure MinValue) && ( pure NominalValue <= pure MaxValue))
    {
      /* convert rotation angle into value change */
      delta = (int32)RotateTouchHandler.Relative * ( pure MaxValue - pure MinValue ) / 720;
    }

    /* caluclate new desired temperature value */
    temp = startValue - delta;
    if ( temp < pure MinValue )
      temp = pure MinValue;
    if ( temp > pure MaxValue )
      temp = pure MaxValue;

    /* inform others about the changed value */
    if ( pure NominalValue != temp )
    {
      var int32 inx = Wheel.FrameNumber;

      /* update the wheel */
      if ( pure NominalValue - temp > 0 )
        inx = inx - 1;
      else
        inx = inx + 1;

      if ( inx < 0 )
        inx = 3;
      if ( inx > 3 )
        inx = 0;

      Wheel.FrameNumber = inx;
      NominalValue = temp;

      /* update the attached outlet, if there is one... */
      if (  OutletNominal != null )
        OutletNominal^ = NominalValue;

      /* ... and inform other observers, that the outlet has changed its value */
      notifyobservers OutletNominal;

    }

  }

  $rect <530,427,730,467>
  slot onEndSlot
  {
    /* end of interaction */
    InvalidateViewState();

    /* restart timer for fading nominal text to actual text */
    FadeTextEffect.Enabled = true;

  }

  $rect <530,310,730,350>
  var int32 startValue;

  $rect <530,260,730,300>
  object Graphics::Path DeltaTempPath;

  $rect <20,20,160,60>
  object Views::StrokePath DeltaTempView
  {
    preset Bounds = <0,0,340,340>;
    preset Color = #0000FFFF;
    preset Width = 4;
    preset Path = DeltaTempPath;
  }

  $rect <20,20,160,60>
  object Views::Image Symbol
  {
    preset Bounds = <210,390,300,450>;
    preset Bitmap = Thermostat::SymbolHeadCool;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text ActualText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <135,210,391,315>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertTop];
    preset String = "20.0°C";
    preset Font = Thermostat::FontXXL;
    preset Color = #000000FF;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text NominalText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <135,210,391,315>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertTop];
    preset String = "20.0°C";
    preset Font = Thermostat::FontXXL;
    preset Color = #000000FF;
    preset Opacity = 0;
  }

  $rect <730,260,930,300>
  object Effects::Int32Effect FadeTextEffect
  {
    preset OnAnimate = fadeText;
    preset NoOfCycles = 1;
    preset CycleDuration = 500;
    preset InitialDelay = 1200;
  }

  $rect <930,260,1130,300>
  slot fadeText
  {
    sender; /* the method is called from the sender object */

    NominalText.Opacity = 0xFF - FadeTextEffect.Value;
    ActualText.Opacity  = FadeTextEffect.Value;

  }

  $rect <210,580,410,620>
  slot incrNominal
  {
    sender; /* the method is called from the sender object */
    var int32 temp = NominalValue + 5;

    /* nominal text has to be shown */
    NominalText.Opacity = 0xFF;
    ActualText.Opacity  = 0x00;
    FadeTextEffect.Enabled = false;

    /* check limits */
    if ( temp > pure MaxValue )
      temp = pure MaxValue;

    NominalValue = temp;

    /* update the attached outlet, if there is one... */
    if (  OutletNominal != null )
      OutletNominal^ = NominalValue;

    /* ... and inform other observers, that the outlet has changed its value */
    notifyobservers OutletNominal;

    /* restart timer for fading nominal text to actual text */
    FadeTextEffect.Enabled = true;
  }

  $rect <210,620,410,660>
  slot decrNominal
  {
    sender; /* the method is called from the sender object */
    var int32 temp = NominalValue - 5;

    /* nominal text has to be shown */
    NominalText.Opacity = 0xFF;
    ActualText.Opacity  = 0x00;
    FadeTextEffect.Enabled = false;

    /* check limits */
    if ( temp < pure MinValue )
      temp = pure MinValue;

    NominalValue = temp;

    /* update the attached outlet, if there is one... */
    if (  OutletNominal != null )
      OutletNominal^ = NominalValue;

    /* ... and inform other observers, that the outlet has changed its value */
    notifyobservers OutletNominal;

    /* restart timer for fading nominal text to actual text */
    FadeTextEffect.Enabled = true;
  }

  // This is a generic touch handler.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandlerPlus
  {
    preset Point4 = <196,210>;
    preset Point3 = <313,210>;
    preset Point2 = <313,105>;
    preset Point1 = <196,105>;
    preset OnPress = incrNominal;
    preset MaxStrikeCount = 100;
  }

  // This is a generic touch handler.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandlerMinus
  {
    preset Point4 = <195,403>;
    preset Point3 = <312,403>;
    preset Point2 = <312,298>;
    preset Point1 = <195,298>;
    preset OnPress = decrNominal;
    preset MaxStrikeCount = 100;
  }

  // This is the core of the SmartThermostat application. This class contains the \
  // both needles for nominal and actual temperature, the rotatable wheel and all \
  // of the calcualtion that is needed to draw the dynamic elements of the thermostat.
  note legend Note
  {
    attr Bounds = <740,310,1140,440>;
  }
}

$rect <550,120,750,160>
$output false
resource Resources::Bitmap Needle
{
  attr bitmapfile FileName = .\Res\Needle.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <40,420,240,460>
$output false
const color ColorCold = #1488D7FF;

$rect <40,460,240,500>
$output false
const color ColorHot = #C70B6AFF;

$rect <550,160,750,200>
$output false
resource Resources::Bitmap SymbolHeadCool
{
  attr bitmapfile FileName = .\Res\SymbolHeadCool.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize = <54,54>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

// Font resources used for the different widgets. If you want to change the fonts \
// within your project, just create a variant of these font resources and define \
// the attributes of the font resources according your design ideas.
$rect <960,40,1160,80>
$output false
resource Resources::Font FontXXL
{
  attr fontname FontName = Roboto Light;
  attr fontheight Height = 108;
  attr fontquality Quality = High;
  attr fontranges Ranges = '0'-'9','.','°','C';
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontheightmode HeightMode = Compatible;
  attr fontrowdistance RowDistance;
}

$rect <40,40,280,80>
$output false
class Thermostat : Core::Group
{
  $rect <1500,10,1700,50>
  inherited property Bounds = <0,0,1280,720>;

  $rect <20,20,160,60>
  object Views::Wallpaper Background
  {
    preset Bounds = <0,0,1280,720>;
    preset Bitmap = Thermostat::BackgroundDay;
  }

  $rect <20,20,160,60>
  object Views::Wallpaper Overlay
  {
    preset Bounds = <0,0,1280,720>;
    preset Bitmap = Thermostat::BackgroundDay;
    preset Opacity = 0;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <1060,570,1180,640>;
    preset Outlet = ^Thermostat::Device.SwingMode;
    preset Label = "Caption";
    preset Appearance = Thermostat::SwingSwitchConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioDay
  {
    preset Bounds = <75,195,375,261>;
    preset Outlet = ^Thermostat::Device.SettingNo;
    preset Label = "Day";
    preset Appearance = Thermostat::RadioButtonDayConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioNight
  {
    preset Bounds = <75,300,375,366>;
    preset OutletSelector = 1;
    preset Outlet = ^Thermostat::Device.SettingNo;
    preset Label = "Night";
    preset Appearance = Thermostat::RadioButtonNightConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton RadioVacation
  {
    preset Bounds = <75,405,375,471>;
    preset OutletSelector = 2;
    preset Outlet = ^Thermostat::Device.SettingNo;
    preset Label = "Vacation";
    preset Appearance = Thermostat::RadioButtonVacationConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalSlider VerticalSlider
  {
    preset Bounds = <1120,165,1140,385>;
    preset Outlet = ^Thermostat::Device.FanSpeed;
    preset Appearance = Thermostat::VerticalSliderConfig;
  }

  $rect <1300,10,1500,50>
  var Thermostat::DeviceClass Device = Thermostat::Device;

  $rect <20,20,160,60>
  object Views::Image FanHi
  {
    preset Bounds = <1050,165,1110,225>;
    preset FrameNumber = 1;
    preset Bitmap = Thermostat::SymbolFan;
  }

  $rect <20,20,160,60>
  object Views::Image FanHi1
  {
    preset Bounds = <1050,450,1110,510>;
    preset FrameNumber = 0;
    preset Bitmap = Thermostat::SymbolFan;
  }

  $rect <20,20,160,60>
  object Thermostat::TemperatureController TemperatureController
  {
    preset Bounds = <405,90,915,600>;
    preset OutletNominal = ^Thermostat::Device.NominalTemp;
    preset OutletActual = ^Thermostat::Device.ActualTemp;
  }

  $rect <20,20,160,60>
  object Views::Text Title
  {
    preset Bounds = <75,0,435,100>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "LIVING ROOM";
    preset Font = Thermostat::FontL;
  }

  $rect <20,20,160,60>
  object Views::Text OnOffButtonText
  {
    preset Bounds = <1060,640,1180,685>;
    preset String = "SWING";
    preset Font = Thermostat::FontM;
  }

  $rect <20,20,160,60>
  object Views::Image ErgosignLogo
  {
    preset Bounds = <60,630,220,680>;
    preset Bitmap = Thermostat::Ergosign;
  }

  $rect <1500,120,1700,160>
  slot changeBackFinished
  {
    sender; /* the method is called from the sender object */

    Background.Bitmap = Overlay.Bitmap;
    Overlay.Opacity = 0x00;

  }

  $rect <1300,120,1500,160>
  object Effects::Int32Effect FadeEffect
  {
    preset OnFinished = changeBackFinished;
    preset NoOfCycles = 1;
    preset Outlet = ^Overlay.Opacity;
  }

  $rect <1300,70,1500,110>
  object Core::PropertyObserver SettingsObserver
  {
    preset OnEvent = onSettingChanged;
    preset Outlet = ^Thermostat::Device.SettingNo;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <1500,70,1700,110>
  slot onSettingChanged
  {
    Overlay.Opacity = 0x00;
    FadeEffect.Enabled = false;

    /* select new background */
    switch ( Device.SettingNo )
    {
      case 0: Overlay.Bitmap = Thermostat::BackgroundDay;
      case 1: Overlay.Bitmap = Thermostat::BackgroundNight;
      default: Overlay.Bitmap = Thermostat::BackgroundDefault;
    }

    FadeEffect.Enabled = true;

  }

  // Slot method to trigger the next phase of the auto demo.
  $rect <1300,400,1500,440>
  slot AutoDemoSlot
  {
    sender; /* the method is called from the sender object */

    switch ( AutoState )
    {
      case  0: Device.NominalTemp = 335;
      case  1: Device.SettingNo = 1;
      case  2: Device.NominalTemp = 185;
      case  3: Device.SettingNo = 2;
      case  4: Device.SettingNo = 0;
      case  5: 
      {
        Device.NominalTemp = 225;
        Device.FanSpeed = 80;
        Device.SwingMode = true;
      }
      case  6: 
      {
        Device.NominalTemp = 190;
        Device.FanSpeed = 30;
        Device.SwingMode = false;
      }
      default:
       ;
    }

    AutoState = AutoState + 1;
    if ( AutoState > 6 )
      AutoState = 0;
  }

  // Variable to store the current phase of the auto demo.
  $rect <1510,400,1710,440>
  var int32 AutoState = 0;

  // Timer object to drive the auto demo mode.
  $rect <1300,440,1500,480>
  object Core::Timer AutoDemoTimer
  {
    preset OnTrigger = AutoDemoSlot;
    preset Period = 4000;
    preset Begin = 0;
  }
}

$rect <750,80,950,120>
$output false
resource Resources::Bitmap BackgroundDay
{
  attr bitmapfile FileName = .\Res\BackgroundDay.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = RGB565;
  attr bitmapmode Mode = Default;
}

$rect <750,120,950,160>
$output false
resource Resources::Bitmap BackgroundNight
{
  attr bitmapfile FileName = .\Res\BackgroundNight.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = RGB565;
  attr bitmapmode Mode = Default;
}

$rect <750,160,950,200>
$output false
resource Resources::Bitmap SymbolFan
{
  attr bitmapfile FileName = .\Res\SymbolFan.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize = <54,54>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

// Font resources used for the different widgets. If you want to change the fonts \
// within your project, just create a variant of these font resources and define \
// the attributes of the font resources according your design ideas.
$rect <960,120,1160,160>
$output false
resource Resources::Font FontM
{
  attr fontname FontName = Roboto Light;
  attr fontheight Height = 36;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontheightmode HeightMode = Compatible;
  attr fontrowdistance RowDistance;
}

$rect <750,40,950,80>
$output false
resource Resources::Bitmap BackgroundDefault
{
  attr bitmapfile FileName = .\Res\BackgroundDefault.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = RGB565;
  attr bitmapmode Mode = Default;
}

// Standard wigets configured for the SmartThermostat
note group Note1
{
  attr Bounds = <20,110,520,370>;
}

$rect <960,160,1160,200>
$output false
resource Resources::Bitmap Ergosign
{
  attr bitmapfile FileName = .\Res\Ergosign.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

// SmartThermostat main screen and temperature controller
note group Note4
{
  attr Bounds = <20,0,520,100>;
}
