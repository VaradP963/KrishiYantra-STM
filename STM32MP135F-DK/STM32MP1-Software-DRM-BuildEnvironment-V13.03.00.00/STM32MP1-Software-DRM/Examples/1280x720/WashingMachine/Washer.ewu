$version 13.00

// Controller class, containing all data set values and all current values of the \
// washing machine.
$rect <40,490,240,530>
$output false
class DeviceClass
{
  // Program number of the washing machine.
  $rect <10,10,210,50>
  property int32 ProgramNumber = 0;

  $rect <10,50,210,90>
  onset ProgramNumber
  {
    // Implement here your ON SET business logic, the access to the hardware,
    // or any desired code to execute, when the property is written at the
    // runtime.

    /* check limits of given value */
    if ( value < 0 )
      value = 0;
    if ( value >= WashingProgram.size )
      value = WashingProgram.size - 1;

    /* check for new value */
    if ( value == pure ProgramNumber )
      return;

    pure ProgramNumber = value;

    notifyobservers ^ProgramNumber;
  }

  // Temperature index of the washing program.
  $rect <220,10,420,50>
  property int32 TempNumber = 0;

  $rect <220,50,420,90>
  onset TempNumber
  {
    // Implement here your ON SET business logic, the access to the hardware,
    // or any desired code to execute, when the property is written at the
    // runtime.

    /* check limits of given value */
    if ( value < 0 )
      value = 0;
    if ( value >= WashingTemp.size )
      value = WashingTemp.size - 1;

    /* check for new value */
    if ( value == pure TempNumber )
      return;

    pure TempNumber = value;

    notifyobservers ^TempNumber;
  }

  // Selected additional option.
  $rect <10,110,210,150>
  property int32 OptionNumber = 0;

  $rect <10,150,210,190>
  onset OptionNumber
  {
    // Implement here your ON SET business logic, the access to the hardware,
    // or any desired code to execute, when the property is written at the
    // runtime.

    /* check limits of given value */
    if ( value < 0 )
      value = 0;
    if ( value >= Options.size )
      value = Options.size - 1;

    /* check for new value */
    if ( value == pure OptionNumber )
      return;

    pure OptionNumber = value;

    notifyobservers ^OptionNumber;
  }

  // Hour of end time.
  $rect <220,110,420,150>
  property int32 Hour = 0;

  $rect <220,150,420,190>
  onset Hour
  {
    // Implement here your ON SET business logic, the access to the hardware,
    // or any desired code to execute, when the property is written at the
    // runtime.

    /* check limits of given value */
    if ( value < 0 )
      value = 0;
    if ( value > 23 )
      value = 23;

    /* check for new value */
    if ( value == pure Hour )
      return;

    pure Hour = value;

    notifyobservers ^Hour;
  }

  // Minute of end time.
  $rect <430,110,630,150>
  property int32 Minute = 0;

  $rect <430,150,630,190>
  onset Minute
  {
    // Implement here your ON SET business logic, the access to the hardware,
    // or any desired code to execute, when the property is written at the
    // runtime.

    /* check limits of given value */
    if ( value < 0 )
      value = 0;
    if ( value > 59 )
      value = 59;

    /* check for new value */
    if ( value == pure Minute )
      return;

    pure Minute = value;

    notifyobservers ^Minute;
  }

  // Index of spin number, when machine is spinning
  $rect <430,10,630,50>
  property int32 SpinNumber = 0;

  $rect <430,50,630,90>
  onset SpinNumber
  {
    // Implement here your ON SET business logic, the access to the hardware,
    // or any desired code to execute, when the property is written at the
    // runtime.

    /* check limits of given value */
    if ( value < 0 )
      value = 0;
    if ( value >= SpinTurn.size )
      value = SpinTurn.size - 1;


    /* check for new value */
    if ( value == pure SpinNumber )
      return;

    pure SpinNumber = value;

    notifyobservers ^SpinNumber;


  }

  // Array of washing programs.
  $rect <690,10,890,50>
  array string WashingProgram[ 8 ] =
  (
    Default[0] = "Hot/Colored Wash";
    Default[1] = "Easy Care";
    Default[2] = "Delicates";
    Default[3] = "Sportswear";
    Default[4] = "Wool Handwash";
    Default[5] = "Eco";
    Default[6] = "Drain";
    Default[7] = "Spin";
  );

  // Array of washing temperatures.
  $rect <690,50,890,90>
  array string WashingTemp[ 6 ] =
  (
    Default[0] = "cold";
    Default[1] = "30°";
    Default[2] = "40°";
    Default[3] = "50°";
    Default[4] = "60°";
    Default[5] = "95°";
  );

  // Array of spin turns.
  $rect <690,90,890,130>
  array string SpinTurn[ 7 ] =
  (
    Default[0] = "none";
    Default[1] = "short";
    Default[2] = "400";
    Default[3] = "800";
    Default[4] = "1000";
    Default[5] = "1200";
    Default[6] = "1400";
  );

  // Array of spin turns.
  $rect <690,130,890,170>
  array string Options[ 6 ] =
  (
    Default[0] = "none";
    Default[1] = "short";
    Default[2] = "extra spinning";
    Default[3] = "pre-^washing";
    Default[4] = "extra rinsing";
    Default[5] = "wrinkle resistance";
  );

  // How to integrate your UI application with a real device?
  // 
  // https://doc.embedded-wizard.de/integrating-with-the-device
  // https://doc.embedded-wizard.de/device-class-and-device-driver
  note legend Note5
  {
    attr Bounds = <10,220,650,310>;
  }
}

// This is a GUI component.
$rect <40,240,240,280>
$output false
class ProgList : Core::Group
{
  $rect <350,370,550,410>
  inherited property Bounds = <0,0,330,600>;

  // This is a slide gesture handler.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,330,600>;
    preset OnEnd = OnEnd;
    preset OnStart = OnStart;
    preset SnapNext = <0,240>;
    preset Friction = 0.1;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,600>;
    preset Point3 = <330,600>;
    preset Point2 = <330,0>;
    preset Point1 = <0,0>;
    preset OnDrag = OnDrag;
    preset OnRelease = OnRelease;
    preset OnPress = OnStart;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,180,330,420>;
    preset Color = Washer::ButtonBgColor;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList BottomList
  {
    preset Bounds = <0,420,330,600>;
    preset Opacity = 0;
    preset OnLoadItem = OnLoadBottom;
    preset ItemHeight = 60;
    preset NoOfItems = Washer::Device.WashingProgram.size;
    preset ItemClass = Washer::ProgItemS;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList MainList
  {
    preset Bounds = <0,180,330,420>;
    preset OnUpdate = OnUpdate;
    preset OnLoadItem = OnLoadMain;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 240;
    preset NoOfItems = Washer::Device.WashingProgram.size;
    preset ItemClass = Washer::ProgItemL;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList TopList
  {
    preset Bounds = <0,0,330,180>;
    preset Opacity = 0;
    preset OnLoadItem = OnLoadTop;
    preset ItemHeight = 60;
    preset NoOfItems = Washer::Device.WashingProgram.size;
    preset ItemClass = Washer::ProgItemS;
  }

  // Slot method to load content of main scroll list.
  $rect <350,90,550,130>
  slot OnLoadMain
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var Washer::ProgItemL itemView = (Washer::ProgItemL)MainList.View;
    var int32             itemNo   = MainList.Item;
    var string            caption  = "";

    /* get caption from corresponding array within device class */
    if (( itemNo >= 0 ) && ( itemNo < Washer::Device.WashingProgram.size ))
      caption = Washer::Device.WashingProgram[ itemNo ];

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( MainList.Bounds.w, MainList.ItemHeight );
  }

  // Slot method to load content of upper scroll list.
  $rect <350,0,550,40>
  slot OnLoadTop
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var Washer::ProgItemS itemView = (Washer::ProgItemS)TopList.View;
    var int32             itemNo   = TopList.Item;
    var string            caption  = "";

    /* get caption from corresponding array within device class */
    if (( itemNo >= 0 ) && ( itemNo < Washer::Device.WashingProgram.size ))
      caption = Washer::Device.WashingProgram[ itemNo ];

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( TopList.Bounds.w, TopList.ItemHeight );
  }

  // Slot method to synchronize the scrolling of the upper/lower list with the current \
  // scroll position of the center list.
  $rect <350,130,550,170>
  slot OnUpdate
  {
    sender; /* the method is called from the sender object */

    /* synchronize upper and lower list  */
    TopList.ScrollOffset = MainList.ScrollOffset * TopList.ItemHeight / MainList.ItemHeight + TopList.Bounds.h;
    BottomList.ScrollOffset = MainList.ScrollOffset * BottomList.ItemHeight / MainList.ItemHeight - BottomList.ItemHeight;



  }

  // Slot method to load content of lower scroll list.
  $rect <350,180,550,220>
  slot OnLoadBottom
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var Washer::ProgItemS itemView = (Washer::ProgItemS)BottomList.View;
    var int32             itemNo   = BottomList.Item;
    var string            caption  = "";

    /* get caption from corresponding array within device class */
    if (( itemNo >= 0 ) && ( itemNo < Washer::Device.WashingProgram.size ))
      caption = Washer::Device.WashingProgram[ itemNo ];

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( BottomList.Bounds.w, BottomList.ItemHeight );
  }

  // Slot method to change the selection, when the item has reached its parking position.
  $rect <550,130,750,170>
  slot OnEnd
  {
    sender; /* the method is called from the sender object */

    /* change the current program according user selection */
    Washer::Device.ProgramNumber = -MainList.ScrollOffset / MainList.ItemHeight;

    /* fade out upper/lower list */
    FadeListOut.Value1 = TopList.Opacity;
    FadeListOut.Enabled = true;

    /* fade in the caption after sliding */
    FadeCaption.Enabled = false;
    FadeCaption.Value1 = Caption.Opacity;
    FadeCaption.Value2 = 0xFF;
    FadeCaption.Enabled = true;

    SimpleTouchHandler.Enabled = true;

  }

  // Slot method to make the upper/lower list visible.
  $rect <550,90,750,130>
  slot OnStart
  {
    sender; /* the method is called from the sender object */

    /* fade in the upper/lower list if not fully opaque */
    if (( TopList.Opacity != 0xFF ) && !FadeListIn.Enabled )
    {
      FadeListIn.Value1 = TopList.Opacity;
      FadeListIn.Enabled = true;
    }
    FadeListOut.Enabled = false;

    /* fade out the caption during sliding */
    FadeCaption.Enabled = false;
    FadeCaption.Value1 = Caption.Opacity;
    FadeCaption.Value2 = 0x00;
    FadeCaption.Enabled = true;


  }

  // This is an int32 change effect.
  $rect <550,0,750,40>
  object Effects::Int32Effect FadeListIn
  {
    preset OnAnimate = onAnimate;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = Washer::FadeInTime;
    preset Outlet = ^TopList.Opacity;
  }

  // This is a slot method.
  $rect <550,40,750,80>
  slot onAnimate
  {
    sender; /* the method is called from the sender object */

    BottomList.Opacity = TopList.Opacity;

  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Caption
  {
    preset Bounds = <30,180,179,239>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Program";
    preset Font = Washer::DescrFont;
    preset Color = Washer::CaptionColor;
  }

  // This is an int32 change effect.
  $rect <750,40,950,80>
  object Effects::Int32Effect FadeCaption
  {
    preset Timing = Effects::Timing.FastIn_FastOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
    preset Outlet = ^Caption.Opacity;
  }

  // This is an int32 change effect.
  $rect <750,0,950,40>
  object Effects::Int32Effect FadeListOut
  {
    preset OnAnimate = onAnimate;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = Washer::FadeOutTime;
    preset InitialDelay = Washer::HoldTime;
    preset Value2 = 0;
    preset Value1 = 255;
    preset Outlet = ^TopList.Opacity;
  }

  $rect <350,270,550,310>
  slot OnDrag
  {
    var point delta = SimpleTouchHandler.CurrentPos - SimpleTouchHandler.HittingPos;

    /* as soon as the user has moved the finger a little bit - pass the touch events
       to the slide touch handler */
    if (( delta.y > 8 ) || ( delta.y < -8 ))
    {
      GetRoot().DeflectCursor( SlideTouchHandler, <0,0> );
      SimpleTouchHandler.Enabled = false;
    }
  }

  $rect <350,230,550,270>
  slot OnRelease
  {
    /* ff the user has just tapped the simple touch handler without sliding, directly select the item */
    if ( !SimpleTouchHandler.AutoDeflected && TopList.Opacity == 0xFF )
    {
      var int32 delta = 0;

      /* calculate the offset in number of items */
      if ( SimpleTouchHandler.CurrentPos.y < MainList.Bounds.y1 )
        delta = ( SimpleTouchHandler.CurrentPos.y - MainList.Bounds.y1 ) / TopList.ItemHeight - 1;
      else if ( SimpleTouchHandler.CurrentPos.y > MainList.Bounds.y2 )
        delta = ( SimpleTouchHandler.CurrentPos.y - MainList.Bounds.y2 ) / BottomList.ItemHeight + 1;

      if ( delta != 0 )
      {
        var int32 item = -MainList.ScrollOffset / MainList.ItemHeight + delta;
        MainList.EnsureVisible( item, true, Int32Effect, null );
        Washer::Device.ProgramNumber = item;
      }
    }

    /* don't forget to start the fade out */
    FadeListOut.Value1 = TopList.Opacity;
    FadeListOut.Enabled = true;

    /* fade in the caption after sliding */
    FadeCaption.Enabled = false;
    FadeCaption.Value1 = Caption.Opacity;
    FadeCaption.Value2 = 0xFF;
    FadeCaption.Enabled = true;

  }

  $rect <550,230,750,270>
  object Effects::Int32Effect Int32Effect
  {
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
  }

  // Slot method to trigger the next phase of the auto demo.
  $rect <350,320,550,360>
  slot AutoDemo
  {
    postsignal OnStart;

    var int32 val = Washer::Device.ProgramNumber + 1;

    if ( val >= Washer::Device.WashingProgram.size )
      val = 0;

    MainList.EnsureVisible( val, true, AutoDemoEffect, OnEnd );

  }

  // This is an int32 change effect.
  $rect <550,320,750,360>
  object Effects::Int32Effect AutoDemoEffect
  {
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset CycleDuration = 300;
  }

  // The class 'ProgList' implements a special type of list to display the washing \
  // program, with a magnification effect of the middle item. For this purpose, three \
  // different vertical lists are used: A top list with small items, a center list \
  // with large items and a bottom list with small items. The three lists are synchronized, \
  // so that it appears for the user as one list. In order to make the list widget \
  // more attractive, the top and bottom list are connected with a fade-in/fade-out \
  // effect: As soon as the user touches the widget, the text item dissappears, and \
  // the top/bottom lists start to fade-in. After a certain idle time, the top/bottom \
  // lists will fade-out.
  note legend Note
  {
    attr Bounds = <350,420,1160,550>;
  }
}

// This is a GUI component.
$rect <40,160,240,200>
$output false
class ProgItemL : Core::Group
{
  $rect <0,260,200,300>
  inherited property Bounds = <0,0,330,240>;

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <20,0,330,240>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text";
    preset Font = Washer::ListFontL;
    preset Color = Washer::ButtonTextColor;
  }

  // The property 'Caption' contains the text of the list item.
  $rect <350,10,550,50>
  property string Caption = "";

  $rect <350,50,550,90>
  onset Caption
  {
    pure Caption = value;
    Text.String = value;
  }
}

// This is a font resource.
$rect <690,430,890,470>
$output false
resource Resources::Font ListFontS
{
  attr fontname FontName = Source Sans Pro;
  attr fontheight Height = 48;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontheightmode HeightMode = Compatible;
  attr fontrowdistance RowDistance;
}

// This is a font resource.
$rect <690,390,890,430>
$output false
resource Resources::Font DescrFont
{
  attr fontname FontName = Source Sans Pro;
  attr fontheight Height = 36;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontheightmode HeightMode = Compatible;
  attr fontrowdistance RowDistance;
}

// This is a font resource.
$rect <690,470,890,510>
$output false
resource Resources::Font ListFontM
{
  attr fontname FontName = Source Sans Pro;
  attr fontheight Height = 57;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontheightmode HeightMode = Compatible;
  attr fontrowdistance RowDistance;
}

// This is a font resource.
$rect <690,510,890,550>
$output false
resource Resources::Font ListFontL
{
  attr fontname FontName = Source Sans Pro;
  attr fontheight Height = 69;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontheightmode HeightMode = Compatible;
  attr fontrowdistance RowDistance;
}

// Color constant according UI design.
$rect <890,160,1090,200>
$output false
const color ButtonBgColor = #E7EAEAFF;

// Color constant according UI design.
$rect <890,40,1090,80>
$output false
const color CaptionColor = #7090A6FF;

// Color constant according UI design.
$rect <890,200,1090,240>
$output false
const color ButtonTextColor = #1B4C59FF;

$rect <240,490,440,530>
$output false
autoobject Washer::DeviceClass Device;

// This is a GUI component.
$rect <40,200,240,240>
$output false
class ProgItemS : Core::Group
{
  $rect <0,190,200,230>
  inherited property Bounds = <0,0,330,60>;

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Back
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,330,60>;
    preset Color = Washer::ListBgColor;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Left
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <0,0,3,60>;
    preset Color = Washer::ListBgColor;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Right
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <327,0,330,60>;
    preset Color = Washer::ListBgColor;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <15,0,315,60>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text";
    preset Font = Washer::ListFontS;
    preset Color = Washer::ListTextColor;
  }

  // The property 'Caption' contains the text of the list item.
  $rect <350,0,550,40>
  property string Caption = "";

  $rect <350,40,550,80>
  onset Caption
  {
    pure Caption = value;
    Text.String = value;
  }
}

// Color constant according UI design.
$rect <890,80,1090,120>
$output false
const color ListBgColor = #FFFFFF40;

// Color constant according UI design.
$rect <890,120,1090,160>
$output false
const color ListTextColor = #FFFFFFFF;

// Constant to define a common animation time for list animations.
$rect <690,40,890,80>
$output false
const int32 FadeInTime = 300;

// Constant to define a common animation time for list animations.
$rect <690,80,890,120>
$output false
const int32 HoldTime = 2000;

// Constant to define a common animation time for list animations.
$rect <690,120,890,160>
$output false
const int32 FadeOutTime = 1000;

// This is a GUI component.
$rect <240,240,440,280>
$output false
class TempList : Core::Group
{
  $rect <240,370,440,410>
  inherited property Bounds = <0,0,120,600>;

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Back
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,119,599>;
    preset Color = #00000000;
  }

  // This is a slide gesture handler.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,120,600>;
    preset OnEnd = OnEnd;
    preset OnStart = OnStart;
    preset SnapNext = <0,240>;
    preset Friction = 0.1;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,600>;
    preset Point3 = <120,600>;
    preset Point2 = <120,0>;
    preset Point1 = <0,0>;
    preset OnDrag = OnDrag;
    preset OnRelease = OnRelease;
    preset OnPress = OnStart;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,180,120,420>;
    preset Color = Washer::ButtonBgColor;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList BottomList
  {
    preset Bounds = <0,420,120,600>;
    preset Opacity = 0;
    preset OnLoadItem = OnLoadBottom;
    preset ItemHeight = 60;
    preset NoOfItems = Washer::Device.WashingTemp.size;
    preset ItemClass = Washer::TempItemS;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList MainList
  {
    preset Bounds = <0,180,120,420>;
    preset Opacity = 0;
    preset OnUpdate = OnUpdate;
    preset OnLoadItem = OnLoadMain;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 240;
    preset NoOfItems = Washer::Device.WashingTemp.size;
    preset ItemClass = Washer::TempItemL;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList TopList
  {
    preset Bounds = <0,0,120,180>;
    preset Opacity = 0;
    preset OnLoadItem = OnLoadTop;
    preset ItemHeight = 60;
    preset NoOfItems = Washer::Device.WashingTemp.size;
    preset ItemClass = Washer::TempItemS;
  }

  // Slot method to load content of main scroll list.
  $rect <240,90,440,130>
  slot OnLoadMain
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var Washer::TempItemL itemView = (Washer::TempItemL)MainList.View;
    var int32             itemNo   = MainList.Item;
    var string            caption  = "";

    /* get caption from corresponding array within device class */
    if (( itemNo >= 0 ) && ( itemNo < Washer::Device.WashingTemp.size ))
      caption = Washer::Device.WashingTemp[ itemNo ];

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( MainList.Bounds.w, MainList.ItemHeight );

    /* assign the top/bottom color to the item */
    switch ( itemNo )
    {
      case 0:
      {
        itemView.ColorTop    = Washer::TempColor0;
        itemView.ColorBottom = Washer::TempColor1;
      }
      case 1:
      {
        itemView.ColorTop    = Washer::TempColor1;
        itemView.ColorBottom = Washer::TempColor2;
      }
      case 2:
      {
        itemView.ColorTop    = Washer::TempColor2;
        itemView.ColorBottom = Washer::TempColor3;
      }
      case 3:
      {
        itemView.ColorTop    = Washer::TempColor3;
        itemView.ColorBottom = Washer::TempColor4;
      }
      case 4:
      {
        itemView.ColorTop    = Washer::TempColor4;
        itemView.ColorBottom = Washer::TempColor5;
      }
      case 5:
      {
        itemView.ColorTop    = Washer::TempColor5;
        itemView.ColorBottom = Washer::TempColor6;
      }
      default:
      ;
    }
  }

  // Slot method to load content of upper scroll list.
  $rect <240,0,440,40>
  slot OnLoadTop
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var Washer::TempItemS itemView = (Washer::TempItemS)TopList.View;
    var int32             itemNo   = TopList.Item;
    var string            caption  = "";

    /* get caption from corresponding array within device class */
    if (( itemNo >= 0 ) && ( itemNo < Washer::Device.WashingTemp.size ))
      caption = Washer::Device.WashingTemp[ itemNo ];

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( TopList.Bounds.w, TopList.ItemHeight );
  }

  // Slot method to synchronize the scrolling of the upper/lower list with the current \
  // scroll position of the center list.
  $rect <240,130,440,170>
  slot OnUpdate
  {
    sender; /* the method is called from the sender object */

    /* synchronize upper and lower list  */
    TopList.ScrollOffset = MainList.ScrollOffset * TopList.ItemHeight / MainList.ItemHeight + TopList.Bounds.h;
    BottomList.ScrollOffset = MainList.ScrollOffset * BottomList.ItemHeight / MainList.ItemHeight - BottomList.ItemHeight;

    /* calculate current border color */
    var int32 itemNo = ( -MainList.ScrollOffset + MainList.ItemHeight / 2 ) / MainList.ItemHeight;
    var int32 dx = (( -MainList.ScrollOffset + MainList.ItemHeight / 2 ) % MainList.ItemHeight) * 0xFF / MainList.ItemHeight;

    if ( dx < 0 )
      dx = 0;

    var color c1 = Washer::TempColor6;
    var color c2 = Washer::TempColor6;

    switch ( itemNo )
    {
      case 0: { c1 = Washer::TempColor0; c2 = Washer::TempColor1; }
      case 1: { c1 = Washer::TempColor1; c2 = Washer::TempColor2; }
      case 2: { c1 = Washer::TempColor2; c2 = Washer::TempColor3; }
      case 3: { c1 = Washer::TempColor3; c2 = Washer::TempColor4; }
      case 4: { c1 = Washer::TempColor4; c2 = Washer::TempColor5; }
      case 5: { c1 = Washer::TempColor5; c2 = Washer::TempColor6; }
      default:
        dx = 0;

    }
    var int32 r = ( c1.red   * ( 0xFF - dx ) + c2.red   * dx ) / 0xFF;
    var int32 g = ( c1.green * ( 0xFF - dx ) + c2.green * dx ) / 0xFF;
    var int32 b = ( c1.blue  * ( 0xFF - dx ) + c2.blue  * dx ) / 0xFF;

    Text.Color = color( (uint8)r, (uint8)g, (uint8)b, 0xFF );

    if ( ColorOutlet != null )
      ColorOutlet^ =  Text.Color;

  }

  // Slot method to load content of lower scroll list.
  $rect <240,180,440,220>
  slot OnLoadBottom
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var Washer::TempItemS itemView = (Washer::TempItemS)BottomList.View;
    var int32             itemNo   = BottomList.Item;
    var string            caption  = "";

    /* get caption from corresponding array within device class */
    if (( itemNo >= 0 ) && ( itemNo < Washer::Device.WashingTemp.size ))
      caption = Washer::Device.WashingTemp[ itemNo ];

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( BottomList.Bounds.w, BottomList.ItemHeight );
  }

  // Slot method to change the selection, when the item has reached its parking position.
  $rect <440,130,640,170>
  slot OnEnd
  {
    sender; /* the method is called from the sender object */

    /* change the current program according user selection */
    Washer::Device.TempNumber = -MainList.ScrollOffset / MainList.ItemHeight;

    /* change the static text according new value */
    Text.String = Washer::Device.WashingTemp[ Washer::Device.TempNumber ];

    /* fade out upper/lower list */
    FadeListOut.Value1 = TopList.Opacity;
    FadeListOut.Enabled = true;

    /* fade in the caption after sliding */
    FadeCaption.Enabled = false;
    FadeCaption.Value1 = Caption.Opacity;
    FadeCaption.Value2 = 0xFF;
    FadeCaption.Enabled = true;

    SimpleTouchHandler.Enabled = true;

  }

  // Slot method to make the upper/lower list visible.
  $rect <440,90,640,130>
  slot OnStart
  {
    sender; /* the method is called from the sender object */

    /* fade in the upper/lower list if not fully opaque */
    if (( TopList.Opacity != 0xFF ) && !FadeListIn.Enabled )
    {
      FadeListIn.Value1 = TopList.Opacity;
      FadeListIn.Enabled = true;
    }
    FadeListOut.Enabled = false;


    /* fade out the caption during sliding */
    FadeCaption.Enabled = false;
    FadeCaption.Value1 = Caption.Opacity;
    FadeCaption.Value2 = 0x00;
    FadeCaption.Enabled = true;


  }

  // This is an int32 change effect.
  $rect <440,0,640,40>
  object Effects::Int32Effect FadeListIn
  {
    preset OnAnimate = onAnimate;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = Washer::FadeInTime;
    preset Outlet = ^TopList.Opacity;
  }

  // This is a slot method.
  $rect <440,40,640,80>
  slot onAnimate
  {
    sender; /* the method is called from the sender object */

    BottomList.Opacity = TopList.Opacity;

    MainList.Opacity = TopList.Opacity;
    Text.Opacity = 0xFF - TopList.Opacity;


  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Caption
  {
    preset Bounds = <15,180,119,239>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Temp.";
    preset Font = Washer::DescrFont;
    preset Color = Washer::CaptionColor;
  }

  // This is an int32 change effect.
  $rect <640,40,840,80>
  object Effects::Int32Effect FadeCaption
  {
    preset Timing = Effects::Timing.FastIn_FastOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
    preset Outlet = ^Caption.Opacity;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,180,119,419>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = Washer::Device.WashingTemp[0];
    preset Font = Washer::ListFontL;
    preset Color = Washer::TempColor0 * Washer::TempColor1;
  }

  // Color outlet to change a color depending on current temperature selection.
  $rect <640,90,840,130>
  property ^color ColorOutlet = null;

  $rect <640,130,840,170>
  onset ColorOutlet
  {
    pure ColorOutlet = value;
  }

  // This is an int32 change effect.
  $rect <640,0,840,40>
  object Effects::Int32Effect FadeListOut
  {
    preset OnAnimate = onAnimate;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = Washer::FadeOutTime;
    preset InitialDelay = Washer::HoldTime;
    preset Value2 = 0;
    preset Value1 = 255;
    preset Outlet = ^TopList.Opacity;
  }

  $rect <240,270,440,310>
  slot OnDrag
  {
    var point delta = SimpleTouchHandler.CurrentPos - SimpleTouchHandler.HittingPos;

    /* as soon as the user has moved the finger a little bit - pass the touch events
       to the slide touch handler */
    if (( delta.y > 8 ) || ( delta.y < -8 ))
    {
      GetRoot().DeflectCursor( SlideTouchHandler, <0,0> );
      SimpleTouchHandler.Enabled = false;
    }
  }

  $rect <240,230,440,270>
  slot OnRelease
  {
    /* ff the user has just tapped the simple touch handler without sliding, directly select the item */
    if ( !SimpleTouchHandler.AutoDeflected && TopList.Opacity == 0xFF )
    {
      var int32 delta = 0;

      /* calculate the offset in number of items */
      if ( SimpleTouchHandler.CurrentPos.y < MainList.Bounds.y1 )
        delta = ( SimpleTouchHandler.CurrentPos.y - MainList.Bounds.y1 ) / TopList.ItemHeight - 1;
      else if ( SimpleTouchHandler.CurrentPos.y > MainList.Bounds.y2 )
        delta = ( SimpleTouchHandler.CurrentPos.y - MainList.Bounds.y2 ) / BottomList.ItemHeight + 1;

      if ( delta != 0 )
      {
        var int32 item = -MainList.ScrollOffset / MainList.ItemHeight + delta;
        MainList.EnsureVisible( item, true, Int32Effect, null );
      }
    }
    /* don't forget to start the fade out */
    signal OnEnd;

  }

  $rect <440,230,640,270>
  object Effects::Int32Effect Int32Effect
  {
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
  }

  // Slot method to trigger the next phase of the auto demo.
  $rect <240,320,440,360>
  slot AutoDemo
  {
    postsignal OnStart;

    var int32 val = Washer::Device.TempNumber + 1;

    if ( val >= Washer::Device.WashingTemp.size )
      val = 0;

    MainList.EnsureVisible( val, true, AutoDemoEffect, OnEnd );

  }

  // This is an int32 change effect.
  $rect <440,320,640,360>
  object Effects::Int32Effect AutoDemoEffect
  {
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset CycleDuration = 300;
  }

  // The class 'TempList' implements a special type of list to display the washing \
  // temperature, with a magnification effect of the middle item. For this purpose, \
  // three different vertical lists are used: A top list with small items, a center \
  // list with large items and a bottom list with small items. The three lists are \
  // synchronized, so that it appears for the user as one list. In order to make \
  // the list widget more attractive, the top and bottom list are connected with \
  // a fade-in/fade-out effect: As soon as the user touches the widget, the text \
  // item dissappears, and the top/bottom lists start to fade-in. After a certain \
  // idle time, the top/bottom lists will fade-out.
  note legend Note
  {
    attr Bounds = <240,420,1050,560>;
  }
}

// This is a GUI component.
$rect <240,160,440,200>
$output false
class TempItemL : Core::Group
{
  $rect <0,270,200,310>
  inherited property Bounds = <0,0,120,240>;

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,120,240>;
    preset Color = Washer::ButtonBgColor;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,120,240>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Text";
    preset Font = Washer::ListFontL;
    preset Color = Washer::ListTextColor;
  }

  // The property 'Caption' contains the text of the list item.
  $rect <250,0,450,40>
  property string Caption = "";

  $rect <250,40,450,80>
  onset Caption
  {
    pure Caption = value;
    Text.String = value;
  }

  // Color of the top border.
  $rect <250,90,450,130>
  property color ColorTop = #FFFFFFFF;

  $rect <250,130,450,170>
  onset ColorTop
  {
    pure ColorTop = value;

    Rectangle.ColorTL = value;
    Rectangle.ColorTR = value;


  }

  // Color of the bottom border.
  $rect <450,90,650,130>
  property color ColorBottom = #FFFFFFFF;

  $rect <450,130,650,170>
  onset ColorBottom
  {
    pure ColorBottom = value;

    Rectangle.ColorBL = value;
    Rectangle.ColorBR = value;


  }
}

// This is a GUI component.
$rect <240,200,440,240>
$output false
class TempItemS : Core::Group
{
  $rect <0,190,200,230>
  inherited property Bounds = <0,0,120,60>;

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Back
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,120,60>;
    preset Color = Washer::ListBgColor;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Right
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <117,0,120,60>;
    preset Color = Washer::ListBgColor;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <15,0,120,60>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text";
    preset Font = Washer::ListFontS;
    preset Color = Washer::ListTextColor;
  }

  // The property 'Caption' contains the text of the list item.
  $rect <250,0,450,40>
  property string Caption = "";

  $rect <250,40,450,80>
  onset Caption
  {
    pure Caption = value;
    Text.String = value;
  }
}

// This is a GUI component.
$rect <440,240,640,280>
$output false
class SpinList : Core::Group
{
  $rect <240,370,440,410>
  inherited property Bounds = <0,0,120,600>;

  // This is a slide gesture handler.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,120,600>;
    preset OnEnd = OnEnd;
    preset OnStart = OnStart;
    preset SnapNext = <0,240>;
    preset Friction = 0.1;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,600>;
    preset Point3 = <120,600>;
    preset Point2 = <120,0>;
    preset Point1 = <0,0>;
    preset OnDrag = OnDrag;
    preset OnRelease = OnRelease;
    preset OnPress = OnStart;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,180,120,420>;
    preset Color = Washer::ButtonBgColor;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList BottomList
  {
    preset Bounds = <0,420,120,600>;
    preset Opacity = 0;
    preset OnLoadItem = OnLoadBottom;
    preset ItemHeight = 60;
    preset NoOfItems = Washer::Device.SpinTurn.size;
    preset ItemClass = Washer::SpinItemS;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList MainList
  {
    preset Bounds = <0,180,120,420>;
    preset OnUpdate = OnUpdate;
    preset OnLoadItem = OnLoadMain;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 240;
    preset NoOfItems = Washer::Device.SpinTurn.size;
    preset ItemClass = Washer::SpinItemL;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList TopList
  {
    preset Bounds = <0,0,120,180>;
    preset Opacity = 0;
    preset OnLoadItem = OnLoadTop;
    preset ItemHeight = 60;
    preset NoOfItems = Washer::Device.SpinTurn.size;
    preset ItemClass = Washer::SpinItemS;
  }

  // Slot method to load content of main scroll list.
  $rect <240,90,440,130>
  slot OnLoadMain
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var Washer::SpinItemL itemView = (Washer::SpinItemL)MainList.View;
    var int32             itemNo   = MainList.Item;
    var string            caption  = "";

    /* get caption from corresponding array within device class */
    if (( itemNo >= 0 ) && ( itemNo < Washer::Device.SpinTurn.size ))
      caption = Washer::Device.SpinTurn[ itemNo ];

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( MainList.Bounds.w, MainList.ItemHeight );
  }

  // Slot method to load content of upper scroll list.
  $rect <240,0,440,40>
  slot OnLoadTop
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var Washer::SpinItemS itemView = (Washer::SpinItemS)TopList.View;
    var int32             itemNo   = TopList.Item;
    var string            caption  = "";

    /* get caption from corresponding array within device class */
    if (( itemNo >= 0 ) && ( itemNo < Washer::Device.SpinTurn.size ))
      caption = Washer::Device.SpinTurn[ itemNo ];

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( TopList.Bounds.w, TopList.ItemHeight );
  }

  // Slot method to synchronize the scrolling of the upper/lower list with the current \
  // scroll position of the center list.
  $rect <240,130,440,170>
  slot OnUpdate
  {
    sender; /* the method is called from the sender object */

    /* synchronize upper and lower list  */
    TopList.ScrollOffset = MainList.ScrollOffset * TopList.ItemHeight / MainList.ItemHeight + TopList.Bounds.h;
    BottomList.ScrollOffset = MainList.ScrollOffset * BottomList.ItemHeight / MainList.ItemHeight - BottomList.ItemHeight;



  }

  // Slot method to load content of lower scroll list.
  $rect <240,180,440,220>
  slot OnLoadBottom
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var Washer::SpinItemS itemView = (Washer::SpinItemS)BottomList.View;
    var int32             itemNo   = BottomList.Item;
    var string            caption  = "";

    /* get caption from corresponding array within device class */
    if (( itemNo >= 0 ) && ( itemNo < Washer::Device.SpinTurn.size ))
      caption = Washer::Device.SpinTurn[ itemNo ];

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( BottomList.Bounds.w, BottomList.ItemHeight );
  }

  // Slot method to change the selection, when the item has reached its parking position.
  $rect <440,130,640,170>
  slot OnEnd
  {
    sender; /* the method is called from the sender object */

    /* change the current program according user selection */
    Washer::Device.SpinNumber = -MainList.ScrollOffset / MainList.ItemHeight;

    /* fade out upper/lower list */
    FadeListOut.Value1 = TopList.Opacity;
    FadeListOut.Enabled = true;

    /* fade in the caption after sliding */
    FadeCaption.Enabled = false;
    FadeCaption.Value1 = Caption.Opacity;
    FadeCaption.Value2 = 0xFF;
    FadeCaption.Enabled = true;

    SimpleTouchHandler.Enabled = true;
  }

  // Slot method to make the upper/lower list visible.
  $rect <440,90,640,130>
  slot OnStart
  {
    sender; /* the method is called from the sender object */

    /* fade in the upper/lower list if not fully opaque */
    if (( TopList.Opacity != 0xFF ) && !FadeListIn.Enabled )
    {
      FadeListIn.Value1 = TopList.Opacity;
      FadeListIn.Enabled = true;
    }
    FadeListOut.Enabled = false;

    /* fade out the caption during sliding */
    FadeCaption.Enabled = false;
    FadeCaption.Value1 = Caption.Opacity;
    FadeCaption.Value2 = 0x00;
    FadeCaption.Enabled = true;


  }

  // This is an int32 change effect.
  $rect <440,0,640,40>
  object Effects::Int32Effect FadeListIn
  {
    preset OnAnimate = onAnimate;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = Washer::FadeInTime;
    preset Outlet = ^TopList.Opacity;
  }

  // This is a slot method.
  $rect <440,40,640,80>
  slot onAnimate
  {
    sender; /* the method is called from the sender object */

    BottomList.Opacity = TopList.Opacity;

  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Caption
  {
    preset Bounds = <15,180,119,239>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "U/min";
    preset Font = Washer::DescrFont;
    preset Color = Washer::CaptionColor;
  }

  // This is an int32 change effect.
  $rect <640,40,840,80>
  object Effects::Int32Effect FadeCaption
  {
    preset Timing = Effects::Timing.FastIn_FastOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
    preset Outlet = ^Caption.Opacity;
  }

  // This is an int32 change effect.
  $rect <640,0,840,40>
  object Effects::Int32Effect FadeListOut
  {
    preset OnAnimate = onAnimate;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = Washer::FadeOutTime;
    preset InitialDelay = Washer::HoldTime;
    preset Value2 = 0;
    preset Value1 = 255;
    preset Outlet = ^TopList.Opacity;
  }

  $rect <240,270,440,310>
  slot OnDrag
  {
    var point delta = SimpleTouchHandler.CurrentPos - SimpleTouchHandler.HittingPos;

    /* as soon as the user has moved the finger a little bit - pass the touch events
       to the slide touch handler */
    if (( delta.y > 8 ) || ( delta.y < -8 ))
    {
      GetRoot().DeflectCursor( SlideTouchHandler, <0,0> );
      SimpleTouchHandler.Enabled = false;
    }
  }

  $rect <240,230,440,270>
  slot OnRelease
  {
    /* ff the user has just tapped the simple touch handler without sliding, directly select the item */
    if ( !SimpleTouchHandler.AutoDeflected && TopList.Opacity == 0xFF )
    {
      var int32 delta = 0;

      /* calculate the offset in number of items */
      if ( SimpleTouchHandler.CurrentPos.y < MainList.Bounds.y1 )
        delta = ( SimpleTouchHandler.CurrentPos.y - MainList.Bounds.y1 ) / TopList.ItemHeight - 1;
      else if ( SimpleTouchHandler.CurrentPos.y > MainList.Bounds.y2 )
        delta = ( SimpleTouchHandler.CurrentPos.y - MainList.Bounds.y2 ) / BottomList.ItemHeight + 1;

      if ( delta != 0 )
      {
        var int32 item = -MainList.ScrollOffset / MainList.ItemHeight + delta;
        MainList.EnsureVisible( item, true, Int32Effect, null );
      }
    }
    /* don't forget to start the fade out */
    signal OnEnd;

  }

  $rect <440,230,640,270>
  object Effects::Int32Effect Int32Effect
  {
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
  }

  // Slot method to trigger the next phase of the auto demo.
  $rect <240,320,440,360>
  slot AutoDemo
  {
    postsignal OnStart;

    var int32 val = Washer::Device.SpinNumber + 1;

    if ( val >= Washer::Device.SpinTurn.size )
      val = 0;

    MainList.EnsureVisible( val, true, AutoDemoEffect, OnEnd );

  }

  // This is an int32 change effect.
  $rect <440,320,640,360>
  object Effects::Int32Effect AutoDemoEffect
  {
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset CycleDuration = 300;
  }

  // The class 'SpinList' implements a special type of list to display the spinning \
  // speed, with a magnification effect of the middle item. For this purpose, three \
  // different vertical lists are used: A top list with small items, a center list \
  // with large items and a bottom list with small items. The three lists are synchronized, \
  // so that it appears for the user as one list. In order to make the list widget \
  // more attractive, the top and bottom list are connected with a fade-in/fade-out \
  // effect: As soon as the user touches the widget, the text item dissappears, and \
  // the top/bottom lists start to fade-in. After a certain idle time, the top/bottom \
  // lists will fade-out.
  note legend Note
  {
    attr Bounds = <240,420,1050,550>;
  }
}

// This is a GUI component.
$rect <440,160,640,200>
$output false
class SpinItemL : Core::Group
{
  $rect <0,260,200,300>
  inherited property Bounds = <0,0,120,240>;

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,0,120,240>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text";
    preset Font = Washer::ListFontM;
    preset Color = Washer::ButtonTextColor;
  }

  // The property 'Caption' contains the text of the list item.
  $rect <250,0,450,40>
  property string Caption = "";

  $rect <250,40,450,80>
  onset Caption
  {
    pure Caption = value;
    Text.String = value;
  }
}

// This is a GUI component.
$rect <440,200,640,240>
$output false
class SpinItemS : Core::Group
{
  $rect <0,190,200,230>
  inherited property Bounds = <0,0,120,60>;

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Back
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,120,60>;
    preset Color = Washer::ListBgColor;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Right
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <117,0,120,60>;
    preset Color = Washer::ListBgColor;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <15,0,120,60>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text";
    preset Font = Washer::ListFontS;
    preset Color = Washer::ListTextColor;
  }

  // The property 'Caption' contains the text of the list item.
  $rect <250,0,450,40>
  property string Caption = "";

  $rect <250,40,450,80>
  onset Caption
  {
    pure Caption = value;
    Text.String = value;
  }
}

// This is a font resource.
$rect <690,550,890,590>
$output false
resource Resources::Font ListFontXL
{
  attr fontname FontName = Source Sans Pro;
  attr fontheight Height = 144;
  attr fontquality Quality = High;
  attr fontranges Ranges = '0'-'9',':';
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontheightmode HeightMode = Compatible;
  attr fontrowdistance RowDistance;
}

// This is a GUI component.
$rect <40,380,240,420>
$output false
class OptList : Core::Group
{
  $rect <260,370,460,410>
  inherited property Bounds = <0,0,240,600>;

  // This is a slide gesture handler.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,240,600>;
    preset OnEnd = OnEnd;
    preset OnStart = OnStart;
    preset SnapNext = <0,240>;
    preset Friction = 0.1;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,600>;
    preset Point3 = <240,600>;
    preset Point2 = <240,0>;
    preset Point1 = <0,0>;
    preset OnDrag = OnDrag;
    preset OnRelease = OnRelease;
    preset OnPress = OnStart;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,180,240,420>;
    preset Color = Washer::ButtonBgColor;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList BottomList
  {
    preset Bounds = <0,420,240,600>;
    preset Opacity = 0;
    preset OnLoadItem = OnLoadBottom;
    preset ItemHeight = 90;
    preset NoOfItems = Washer::Device.Options.size;
    preset ItemClass = Washer::OptItemS;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList MainList
  {
    preset Bounds = <0,180,240,420>;
    preset OnUpdate = OnUpdate;
    preset OnLoadItem = OnLoadMain;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 240;
    preset NoOfItems = Washer::Device.Options.size;
    preset ItemClass = Washer::OptItemL;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList TopList
  {
    preset Bounds = <0,0,240,180>;
    preset Opacity = 0;
    preset OnLoadItem = OnLoadTop;
    preset ItemHeight = 90;
    preset NoOfItems = Washer::Device.Options.size;
    preset ItemClass = Washer::OptItemS;
  }

  // Slot method to load content of main scroll list.
  $rect <260,90,460,130>
  slot OnLoadMain
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var Washer::OptItemL itemView = (Washer::OptItemL)MainList.View;
    var int32             itemNo   = MainList.Item;
    var string            caption  = "";

    /* get caption from corresponding array within device class */
    if (( itemNo >= 0 ) && ( itemNo < Washer::Device.Options.size ))
      caption = Washer::Device.Options[ itemNo ];

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( MainList.Bounds.w, MainList.ItemHeight );
  }

  // Slot method to load content of upper scroll list.
  $rect <260,0,460,40>
  slot OnLoadTop
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var Washer::OptItemS itemView = (Washer::OptItemS)TopList.View;
    var int32             itemNo   = TopList.Item;
    var string            caption  = "";

    /* get caption from corresponding array within device class */
    if (( itemNo >= 0 ) && ( itemNo < Washer::Device.Options.size ))
      caption = Washer::Device.Options[ itemNo ];

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( TopList.Bounds.w, TopList.ItemHeight );
  }

  // Slot method to synchronize the scrolling of the upper/lower list with the current \
  // scroll position of the center list.
  $rect <260,130,460,170>
  slot OnUpdate
  {
    sender; /* the method is called from the sender object */

    /* synchronize upper and lower list  */
    TopList.ScrollOffset = MainList.ScrollOffset * TopList.ItemHeight / MainList.ItemHeight + TopList.Bounds.h;
    BottomList.ScrollOffset = MainList.ScrollOffset * BottomList.ItemHeight / MainList.ItemHeight - BottomList.ItemHeight;



  }

  // Slot method to load content of lower scroll list.
  $rect <260,180,460,220>
  slot OnLoadBottom
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var Washer::OptItemS itemView = (Washer::OptItemS)BottomList.View;
    var int32             itemNo   = BottomList.Item;
    var string            caption  = "";

    /* get caption from corresponding array within device class */
    if (( itemNo >= 0 ) && ( itemNo < Washer::Device.Options.size ))
      caption = Washer::Device.Options[ itemNo ];

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( BottomList.Bounds.w, BottomList.ItemHeight );
  }

  // Slot method to change the selection, when the item has reached its parking position.
  $rect <460,130,660,170>
  slot OnEnd
  {
    sender; /* the method is called from the sender object */

    /* change the current program according user selection */
    Washer::Device.OptionNumber = -MainList.ScrollOffset / MainList.ItemHeight;

    /* fade out upper/lower list */
    FadeListOut.Value1 = TopList.Opacity;
    FadeListOut.Enabled = true;

    /* fade in the caption after sliding */
    FadeCaption.Enabled = false;
    FadeCaption.Value1 = Caption.Opacity;
    FadeCaption.Value2 = 0xFF;
    FadeCaption.Enabled = true;

    SimpleTouchHandler.Enabled = true;
  }

  // Slot method to make the upper/lower list visible.
  $rect <460,90,660,130>
  slot OnStart
  {
    sender; /* the method is called from the sender object */

    /* fade in the upper/lower list if not fully opaque */
    if (( TopList.Opacity != 0xFF ) && !FadeListIn.Enabled )
    {
      FadeListIn.Value1 = TopList.Opacity;
      FadeListIn.Enabled = true;
    }
    FadeListOut.Enabled = false;

    /* fade out the caption during sliding */
    FadeCaption.Enabled = false;
    FadeCaption.Value1 = Caption.Opacity;
    FadeCaption.Value2 = 0x00;
    FadeCaption.Enabled = true;


  }

  // This is an int32 change effect.
  $rect <460,0,660,40>
  object Effects::Int32Effect FadeListIn
  {
    preset OnAnimate = onAnimate;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = Washer::FadeInTime;
    preset Outlet = ^TopList.Opacity;
  }

  // This is a slot method.
  $rect <460,40,660,80>
  slot onAnimate
  {
    sender; /* the method is called from the sender object */

    BottomList.Opacity = TopList.Opacity;

  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Caption
  {
    preset Bounds = <15,180,164,239>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Options";
    preset Font = Washer::DescrFont;
    preset Color = Washer::CaptionColor;
  }

  // This is an int32 change effect.
  $rect <660,40,860,80>
  object Effects::Int32Effect FadeCaption
  {
    preset Timing = Effects::Timing.FastIn_FastOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
    preset Outlet = ^Caption.Opacity;
  }

  // This is an int32 change effect.
  $rect <660,0,860,40>
  object Effects::Int32Effect FadeListOut
  {
    preset OnAnimate = onAnimate;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = Washer::FadeOutTime;
    preset InitialDelay = Washer::HoldTime;
    preset Value2 = 0;
    preset Value1 = 255;
    preset Outlet = ^TopList.Opacity;
  }

  $rect <260,270,460,310>
  slot OnDrag
  {
    var point delta = SimpleTouchHandler.CurrentPos - SimpleTouchHandler.HittingPos;

    /* as soon as the user has moved the finger a little bit - pass the touch events
       to the slide touch handler */
    if (( delta.y > 8 ) || ( delta.y < -8 ))
    {
      GetRoot().DeflectCursor( SlideTouchHandler, <0,0> );
      SimpleTouchHandler.Enabled = false;
    }
  }

  $rect <260,230,460,270>
  slot OnRelease
  {
    /* ff the user has just tapped the simple touch handler without sliding, directly select the item */
    if ( !SimpleTouchHandler.AutoDeflected && TopList.Opacity == 0xFF )
    {
      var int32 delta = 0;

      /* calculate the offset in number of items */
      if ( SimpleTouchHandler.CurrentPos.y < MainList.Bounds.y1 )
        delta = ( SimpleTouchHandler.CurrentPos.y - MainList.Bounds.y1 ) / TopList.ItemHeight - 1;
      else if ( SimpleTouchHandler.CurrentPos.y > MainList.Bounds.y2 )
        delta = ( SimpleTouchHandler.CurrentPos.y - MainList.Bounds.y2 ) / BottomList.ItemHeight + 1;

      if ( delta != 0 )
      {
        var int32 item = -MainList.ScrollOffset / MainList.ItemHeight + delta;
        MainList.EnsureVisible( item, true, Int32Effect, null );
      }
    }
    /* don't forget to start the fade out */
    signal OnEnd;

  }

  $rect <460,230,660,270>
  object Effects::Int32Effect Int32Effect
  {
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
  }

  // Slot method to trigger the next phase of the auto demo.
  $rect <260,320,460,360>
  slot AutoDemo
  {
    postsignal OnStart;

    var int32 val = Washer::Device.OptionNumber + 1;

    if ( val >= Washer::Device.Options.size )
      val = 0;

    MainList.EnsureVisible( val, true, AutoDemoEffect, OnEnd );

  }

  // This is an int32 change effect.
  $rect <460,320,660,360>
  object Effects::Int32Effect AutoDemoEffect
  {
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset CycleDuration = 300;
  }

  // The class 'OptList' implements a special type of list to display the washing \
  // options, with a magnification effect of the middle item. For this purpose, three \
  // different vertical lists are used: A top list with small items, a center list \
  // with large items and a bottom list with small items. The three lists are synchronized, \
  // so that it appears for the user as one list. In order to make the list widget \
  // more attractive, the top and bottom list are connected with a fade-in/fade-out \
  // effect: As soon as the user touches the widget, the text item dissappears, and \
  // the top/bottom lists start to fade-in. After a certain idle time, the top/bottom \
  // lists will fade-out.
  note legend Note
  {
    attr Bounds = <260,420,1070,550>;
  }
}

// This is a GUI component.
$rect <40,300,240,340>
$output false
class OptItemL : Core::Group
{
  $rect <0,260,200,300>
  inherited property Bounds = <0,0,240,240>;

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,0,240,240>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text";
    preset Font = Washer::ListFontM;
    preset Color = Washer::ButtonTextColor;
  }

  // The property 'Caption' contains the text of the list item.
  $rect <250,0,450,40>
  property string Caption = "";

  $rect <250,40,450,80>
  onset Caption
  {
    pure Caption = value;
    Text.String = value;
  }
}

// This is a GUI component.
$rect <40,340,240,380>
$output false
class OptItemS : Core::Group
{
  $rect <0,190,200,230>
  inherited property Bounds = <0,0,240,90>;

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Back
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,240,90>;
    preset Color = Washer::ListBgColor;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Right
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <237,0,240,90>;
    preset Color = Washer::ListBgColor;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <15,0,225,90>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text";
    preset Font = Washer::ListFontS;
    preset Color = Washer::ListTextColor;
  }

  // The property 'Caption' contains the text of the list item.
  $rect <250,0,450,40>
  property string Caption = "";

  $rect <250,40,450,80>
  onset Caption
  {
    pure Caption = value;
    Text.String = value;
  }
}

// This is a GUI component.
$rect <40,40,240,80>
$output false
class Washer : Core::Group
{
  $rect <1310,50,1510,90>
  inherited property Bounds = <0,0,1280,720>;

  $rect <1310,10,1510,50>
  inherited method Init()
  {
    postsignal onUpdateProgram;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,1280,720>;
    preset Color = #226173FF;
  }

  // This is an image view.
  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,1280,720>;
    preset Color = #000000FF;
  }

  // This is a bitmap frame view.
  $rect <20,20,160,60>
  object Views::Frame Frame
  {
    preset Bounds = <70,225,1240,495>;
    preset Color = #00000080;
    preset Edges = Graphics::Edges[Bottom, Left, Right, Top];
    preset Bitmap = Washer::Shadow;
  }

  $rect <20,20,160,60>
  object Washer::ProgList ProgList
  {
    preset Bounds = <70,45,400,645>;
  }

  $rect <20,20,160,60>
  object Washer::TempList TempList
  {
    preset Bounds = <400,45,520,645>;
    preset ColorOutlet = ^Border.Color;
  }

  $rect <20,20,160,60>
  object Washer::SpinList SpinList
  {
    preset Bounds = <520,45,640,645>;
  }

  $rect <20,20,160,60>
  object Washer::OptList OptList
  {
    preset Bounds = <640,45,880,645>;
  }

  $rect <20,20,160,60>
  object Washer::TimeList TimeList
  {
    preset Bounds = <880,45,1210,585>;
    preset OnAppear = OnListAppear;
    preset OnDisappear = OnListDisappear;
  }

  // This is a border view.
  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <70,225,1210,465>;
    preset Width = 2;
    preset Color = #FFC200FF;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Sep1
  {
    preset Bounds = <398,255,401,435>;
    preset Color = #40404040;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Sep2
  {
    preset Bounds = <518,255,521,435>;
    preset Color = #40404040;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Sep3
  {
    preset Bounds = <638,255,641,435>;
    preset Color = #40404040;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Sep4
  {
    preset Bounds = <878,255,881,435>;
    preset Color = #40404040;
  }

  // Slot method to update the display value.
  $rect <10,780,210,820>
  slot onUpdateProgram
  {
    sender; /* the method is called from the sender object */

    /* fade out the background */
    FadeBgEffect.Enabled = false;
    FadeBgEffect.Value1 = Image.Opacity;
    FadeBgEffect.Value2 = 0x00;
    FadeBgEffect.Enabled = true;




  }

  // This variable refers to the autoobject 'Washer::Device'. It is used to keep \
  // the device object within the memory during the whole liefetime of the application.
  $rect <1310,90,1510,130>
  var Washer::DeviceClass Device = Washer::Device;

  // This is an int32 change effect.
  $rect <220,740,420,780>
  object Effects::Int32Effect FadeBgEffect
  {
    preset OnFinished = changeBackground;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
    preset Outlet = ^Image.Opacity;
  }

  // This is a slot method.
  $rect <220,780,420,820>
  slot changeBackground
  {
    sender; /* the method is called from the sender object */
    if ( Image.Opacity == 0x00 )
    {
      switch ( Device.ProgramNumber )
      {
        case 0:
          Image.Bitmap = Washer::BgHot;
        case 1:
          Image.Bitmap = Washer::BgEasyCare;
        case 2:
          Image.Bitmap = Washer::BgDelicates;
        case 3:
          Image.Bitmap = Washer::BgSportswear;
        case 4:
          Image.Bitmap = Washer::BgWool;
        case 5:
          Image.Bitmap = Washer::BgEco;
        case 6:
          Image.Bitmap = Washer::BgDrain;
        case 7:
          Image.Bitmap = Washer::BgSpin;
        default:
          Image.Bitmap = null;
      }
      FadeBgEffect.Enabled = false;
      FadeBgEffect.Value1 = Image.Opacity;
      FadeBgEffect.Value2 = 0xFF;
      postsignal FadeBgEffect.StartEffect;
    }
  }

  $rect <20,20,160,60>
  object Washer::StartButton StartButton
  {
    preset Bounds = <880,469,1240,589>;
    preset OnChange = onStart;
  }

  // This is a move and resize rectangle effect.
  $rect <1310,240,1510,280>
  object Effects::RectEffect MoveStartEffect
  {
    preset Timing = Effects::Timing.FastIn_FastOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
    preset Value2 = <880,585,1240,705>;
    preset Value1 = <880,470,1240,590>;
    preset Outlet = ^StartButton.Bounds;
  }

  // Slot to receive signal that time list will appear.
  $rect <1310,160,1510,200>
  slot OnListAppear
  {
    sender; /* the method is called from the sender object */


    MoveStartEffect.Reversed = false;
    MoveStartEffect.Enabled = true;

  }

  // Slot to receive signal that time list has disappeared.
  $rect <1310,200,1510,240>
  slot OnListDisappear
  {
    sender; /* the method is called from the sender object */

    MoveStartEffect.Reversed = true;
    MoveStartEffect.Enabled = true;

  }

  $rect <1310,310,1510,350>
  slot onStart
  {
    sender; /* the method is called from the sender object */

    MessageEffect.Enabled = false;
    Message.Opacity = 0xFF;
    MessageEffect.Enabled = true;
  }

  // This is an int32 change effect.
  $rect <1310,350,1510,390>
  object Effects::Int32Effect MessageEffect
  {
    preset NoOfCycles = 1;
    preset InitialDelay = 2000;
    preset Value2 = 0;
    preset Value1 = 255;
    preset Outlet = ^Message.Opacity;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Message
  {
    preset Bounds = <85,660,895,720>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Sorry, this demo application cannot wash your clothes...";
    preset Font = Washer::DescrFont;
    preset Opacity = 0;
  }

  // Slot method to trigger the next phase of the auto demo.
  $rect <1310,420,1510,460>
  slot AutoDemoSlot
  {
    sender; /* the method is called from the sender object */

    switch ( AutoState )
    {
    //  case  0: postsignal ProgList.AutoDemo;
      case  1: postsignal ProgList.AutoDemo;
      case  2: postsignal TempList.AutoDemo;
      case  3: postsignal SpinList.AutoDemo;
      case  4: postsignal OptList.AutoDemo;
      case  5:
      {
        postsignal TempList.AutoDemo;
        postsignal SpinList.AutoDemo;
      }
      case  6:
      {
        postsignal ProgList.AutoDemo;
        postsignal TempList.AutoDemo;
      }
      case  7:
      {
        postsignal ProgList.AutoDemo;
        postsignal SpinList.AutoDemo;
        postsignal OptList.AutoDemo;
      }
      default:
       ;
    }

    AutoState = AutoState + 1;
    if ( AutoState > 7 )
      AutoState = 0;
  }

  // Variable to store the current phase of the auto demo.
  $rect <1310,500,1510,540>
  var int32 AutoState = 0;

  // This is the main screen of the washing machine. It arranges the different scrollable \
  // list widgets.
  // 
  // The slot methods 'OnListAppear' and 'OnListDisappear' are responsible to move \
  // the start button out of the list area as soon as the time list appears. When \
  // the user presses the start button, the method 'onStart' will be called and a \
  // message appears.
  // The slot method 'onUpdateProgram' triggers the fade-out/fade-in effect of the \
  // background image. It is signaled by the 'ProgramObserver' which listens to the \
  // 'ProgramNumber' of the 'Device'. 
  // 
  // To run the application within the Prototyper, press 'F5'.
  note legend Note1
  {
    attr Bounds = <10,830,810,1010>;
  }

  // This object is a handler of property notifications.
  $rect <10,740,210,780>
  object Core::PropertyObserver ProgramObserver
  {
    preset OnEvent = onUpdateProgram;
    preset Outlet = ^Washer::Device.ProgramNumber;
  }

  // Timer object to drive the auto demo mode.
  $rect <1310,460,1510,500>
  object Core::Timer AutoDemoTimer
  {
    preset OnTrigger = AutoDemoSlot;
    preset Period = 1500;
    preset Begin = 0;
  }
}

// This is a GUI component.
$rect <240,340,440,380>
$output false
class HourItemS : Core::Group
{
  $rect <0,190,200,230>
  inherited property Bounds = <0,0,165,60>;

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Back
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,165,60>;
    preset Color = Washer::ListBgColor;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Center
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <164,0,165,60>;
    preset Color = Washer::ButtonTextColor;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,165,60>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Text";
    preset Font = Washer::ListFontS;
    preset Color = Washer::ListTextColor;
  }

  // The property 'Caption' contains the text of the list item.
  $rect <250,0,450,40>
  property string Caption = "";

  $rect <250,40,450,80>
  onset Caption
  {
    pure Caption = value;
    Text.String = value;
  }
}

// This is a GUI component.
$rect <240,380,640,420>
$output false
class TimeList : Core::Group
{
  $rect <350,360,550,400>
  inherited property Bounds = <0,0,330,540>;

  // This is a slide gesture handler.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandlerH
  {
    preset Bounds = <0,0,165,540>;
    preset OnEnd = OnEnd;
    preset OnStart = OnStart;
    preset SnapNext = <0,240>;
    preset Friction = 0.1;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandlerH
  {
    preset Point4 = <0,540>;
    preset Point3 = <165,540>;
    preset Point2 = <165,0>;
    preset Point1 = <0,0>;
    preset OnDrag = OnDragH;
    preset OnRelease = OnReleaseH;
    preset OnPress = OnStart;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,180,330,420>;
    preset Color = Washer::ButtonBgColor;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList BottomListH
  {
    preset Bounds = <0,420,165,540>;
    preset Opacity = 0;
    preset OnLoadItem = OnLoadBottomH;
    preset ItemHeight = 60;
    preset NoOfItems = 24;
    preset ItemClass = Washer::HourItemS;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList MainListH
  {
    preset Bounds = <0,180,165,420>;
    preset OnUpdate = OnUpdateH;
    preset OnLoadItem = OnLoadMainH;
    preset SlideHandler = SlideTouchHandlerH;
    preset ItemHeight = 240;
    preset NoOfItems = 24;
    preset ItemClass = Washer::HourItemL;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList TopListH
  {
    preset Bounds = <0,0,165,180>;
    preset Opacity = 0;
    preset OnLoadItem = OnLoadTopH;
    preset ItemHeight = 60;
    preset NoOfItems = 24;
    preset ItemClass = Washer::HourItemS;
  }

  // Slot method to load content of main scroll list.
  $rect <350,130,550,170>
  slot OnLoadMainH
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var Washer::HourItemL itemView = (Washer::HourItemL)MainListH.View;
    var int32             itemNo   = MainListH.Item;
    var string            caption  = string( itemNo );

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( MainListH.Bounds.w, MainListH.ItemHeight );
  }

  // Slot method to load content of upper scroll list.
  $rect <350,0,550,40>
  slot OnLoadTopH
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var Washer::HourItemS itemView = (Washer::HourItemS)TopListH.View;
    var int32             itemNo   = TopListH.Item;
    var string            caption  = string( itemNo );

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( TopListH.Bounds.w, TopListH.ItemHeight );
  }

  // Slot method to synchronize the scrolling of the upper/lower list with the current \
  // scroll position of the center list.
  $rect <350,170,550,210>
  slot OnUpdateH
  {
    sender; /* the method is called from the sender object */

    /* synchronize upper and lower list  */
    TopListH.ScrollOffset = MainListH.ScrollOffset * TopListH.ItemHeight / MainListH.ItemHeight + TopListH.Bounds.h;
    BottomListH.ScrollOffset = MainListH.ScrollOffset * BottomListH.ItemHeight / MainListH.ItemHeight - BottomListH.ItemHeight;



  }

  // Slot method to load content of lower scroll list.
  $rect <350,220,550,260>
  slot OnLoadBottomH
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var Washer::HourItemS itemView = (Washer::HourItemS)BottomListH.View;
    var int32             itemNo   = BottomListH.Item;
    var string            caption  = string( itemNo );

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( BottomListH.Bounds.w, BottomListH.ItemHeight );
  }

  // Slot method to change the selection, when the item has reached its parking position.
  $rect <750,170,950,210>
  slot OnEnd
  {
    sender; /* the method is called from the sender object */

    /* change the current program according user selection */
    Washer::Device.Hour = -MainListH.ScrollOffset / MainListH.ItemHeight;
    Washer::Device.Minute = -MainListM.ScrollOffset / MainListM.ItemHeight;

    /* fade out upper/lower list */
    FadeListOut.Value1 = TopListH.Opacity;
    FadeListOut.Enabled = true;

    /* fade in the caption after sliding */
    FadeCaption.Enabled = false;
    FadeCaption.Value1 = Caption.Opacity;
    FadeCaption.Value2 = 0xFF;
    FadeCaption.Enabled = true;

    SimpleTouchHandlerH.Enabled = true;
    SimpleTouchHandlerM.Enabled = true;

  }

  // Slot method to make the upper/lower list visible.
  $rect <750,130,950,170>
  slot OnStart
  {
    sender; /* the method is called from the sender object */

    /* fade in the upper/lower list if not fully opaque */
    if (( TopListH.Opacity != 0xFF ) && !FadeListIn.Enabled )
    {
      FadeListIn.Value1 = TopListH.Opacity;
      FadeListIn.Enabled = true;
    }
    FadeListOut.Enabled = false;

    /* fade out the caption during sliding */
    FadeCaption.Enabled = false;
    FadeCaption.Value1 = Caption.Opacity;
    FadeCaption.Value2 = 0x00;
    FadeCaption.Enabled = true;

    /* fade out the duration during sliding */
    FadeDuration.Enabled = false;
    FadeDuration.Value1 = DurationText.Opacity;
    FadeDuration.Value2 = 0x00;
    FadeDuration.Enabled = true;

    if ( TopListH.Opacity == 0x00 )
      postsignal OnAppear;
  }

  // This is an int32 change effect.
  $rect <750,0,950,40>
  object Effects::Int32Effect FadeListIn
  {
    preset OnAnimate = onAnimate;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = Washer::FadeInTime;
    preset Outlet = ^TopListH.Opacity;
  }

  // This is a slot method.
  $rect <750,40,950,80>
  slot onAnimate
  {
    sender; /* the method is called from the sender object */

    TopListM.Opacity = TopListH.Opacity;
    BottomListH.Opacity = TopListH.Opacity;
    BottomListM.Opacity = TopListH.Opacity;

  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Caption
  {
    preset Bounds = <30,180,149,239>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Finish";
    preset Font = Washer::DescrFont;
    preset Color = Washer::CaptionColor;
  }

  // This is an int32 change effect.
  $rect <950,40,1150,80>
  object Effects::Int32Effect FadeCaption
  {
    preset Timing = Effects::Timing.FastIn_FastOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
    preset Outlet = ^Caption.Opacity;
  }

  // This is a slide gesture handler.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandlerM
  {
    preset Bounds = <164,0,329,540>;
    preset OnEnd = OnEnd;
    preset OnStart = OnStart;
    preset SnapNext = <0,240>;
    preset Friction = 0.1;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandlerM
  {
    preset Point4 = <165,540>;
    preset Point3 = <330,540>;
    preset Point2 = <330,0>;
    preset Point1 = <165,0>;
    preset OnDrag = OnDragM;
    preset OnRelease = OnReleaseM;
    preset OnPress = OnStart;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList BottomListM
  {
    preset Bounds = <165,420,330,540>;
    preset Opacity = 0;
    preset OnLoadItem = OnLoadBottomM;
    preset ItemHeight = 60;
    preset NoOfItems = 60;
    preset ItemClass = Washer::MinItemS;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList MainListM
  {
    preset Bounds = <165,180,330,420>;
    preset OnUpdate = OnUpdateM;
    preset OnLoadItem = OnLoadMainM;
    preset SlideHandler = SlideTouchHandlerM;
    preset ItemHeight = 240;
    preset NoOfItems = 60;
    preset ItemClass = Washer::MinItemL;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList TopListM
  {
    preset Bounds = <165,0,330,180>;
    preset Opacity = 0;
    preset OnLoadItem = OnLoadTopM;
    preset ItemHeight = 60;
    preset NoOfItems = 60;
    preset ItemClass = Washer::MinItemS;
  }

  // Slot method to load content of main scroll list.
  $rect <550,130,750,170>
  slot OnLoadMainM
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var Washer::MinItemL itemView = (Washer::MinItemL)MainListM.View;
    var int32             itemNo   = MainListM.Item;
    var string            caption  = string( itemNo, 2 );

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( MainListM.Bounds.w, MainListM.ItemHeight );
  }

  // Slot method to load content of upper scroll list.
  $rect <550,0,750,40>
  slot OnLoadTopM
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var Washer::MinItemS itemView = (Washer::MinItemS)TopListM.View;
    var int32             itemNo   = TopListM.Item;
    var string            caption  = string( itemNo, 2 );

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( TopListM.Bounds.w, TopListM.ItemHeight );
  }

  // Slot method to load content of lower scroll list.
  $rect <550,220,750,260>
  slot OnLoadBottomM
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var Washer::MinItemS itemView = (Washer::MinItemS)BottomListM.View;
    var int32             itemNo   = BottomListM.Item;
    var string            caption  = string( itemNo, 2 );

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( BottomListM.Bounds.w, BottomListM.ItemHeight );
  }

  // Slot method to synchronize the scrolling of the upper/lower list with the current \
  // scroll position of the center list.
  $rect <550,170,750,210>
  slot OnUpdateM
  {
    sender; /* the method is called from the sender object */

    /* synchronize upper and lower list  */
    TopListM.ScrollOffset = MainListM.ScrollOffset * TopListM.ItemHeight / MainListM.ItemHeight + TopListM.Bounds.h;
    BottomListM.ScrollOffset = MainListM.ScrollOffset * BottomListM.ItemHeight / MainListM.ItemHeight - BottomListM.ItemHeight;



  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <149,180,179,419>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = ":";
    preset Font = Washer::ListFontXL;
    preset Color = Washer::ButtonTextColor;
  }

  // Slot property to signal that upper/lower list will appear.
  $rect <950,130,1150,170>
  property slot OnAppear = null;

  // Slot property to signal that upper/lower list has disappeared.
  $rect <950,170,1150,210>
  property slot OnDisappear = null;

  // This is a slot method.
  $rect <750,80,950,120>
  slot onFinished
  {
    sender; /* the method is called from the sender object */

    if ( FadeListOut.Value == 0x00 )
    {
      postsignal OnDisappear;

      /* fade in the duration after sliding */
      FadeDuration.Enabled = false;
      FadeDuration.Value1 = Caption.Opacity;
      FadeDuration.Value2 = 0xFF;
      FadeDuration.Enabled = true;
    }
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text DurationText
  {
    preset Bounds = <30,359,329,419>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Duration: 2h 45min";
    preset Font = Washer::DescrFont;
    preset Color = Washer::CaptionColor;
  }

  // This is an int32 change effect.
  $rect <950,80,1150,120>
  object Effects::Int32Effect FadeDuration
  {
    preset Timing = Effects::Timing.FastIn_FastOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
    preset Outlet = ^DurationText.Opacity;
  }

  // This is an int32 change effect.
  $rect <950,0,1150,40>
  object Effects::Int32Effect FadeListOut
  {
    preset OnFinished = onFinished;
    preset OnAnimate = onAnimate;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = Washer::FadeOutTime;
    preset InitialDelay = Washer::HoldTime;
    preset Value2 = 0;
    preset Value1 = 255;
    preset Outlet = ^TopListH.Opacity;
  }

  $rect <350,310,550,350>
  slot OnDragH
  {
     var point delta = SimpleTouchHandlerH.CurrentPos - SimpleTouchHandlerH.HittingPos;

    /* as soon as the user has moved the finger a little bit - pass the touch events
       to the slide touch handler */
    if (( delta.y > 8 ) || ( delta.y < -8 ))
    {
      GetRoot().DeflectCursor( SlideTouchHandlerH, <0,0> );
      SimpleTouchHandlerH.Enabled = false;
    }
  }

  $rect <350,270,550,310>
  slot OnReleaseH
  {
    /* ff the user has just tapped the simple touch handler without sliding, directly select the item */
    if ( !SimpleTouchHandlerH.AutoDeflected && TopListH.Opacity == 0xFF )
    {
      var int32 delta = 0;

      /* calculate the offset in number of items */
      if ( SimpleTouchHandlerH.CurrentPos.y < MainListH.Bounds.y1 )
        delta = ( SimpleTouchHandlerH.CurrentPos.y - MainListH.Bounds.y1 ) / TopListH.ItemHeight - 1;
      else if ( SimpleTouchHandlerH.CurrentPos.y > MainListH.Bounds.y2 )
        delta = ( SimpleTouchHandlerH.CurrentPos.y - MainListH.Bounds.y2 ) / BottomListH.ItemHeight + 1;

      if ( delta != 0 )
      {
        var int32 item = -MainListH.ScrollOffset / MainListH.ItemHeight + delta;
        MainListH.EnsureVisible( item, true, Int32EffectH, null );
      }
    }
    /* don't forget to start the fade out */
    signal OnEnd;

  }

  $rect <550,270,750,310>
  object Effects::Int32Effect Int32EffectH
  {
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
  }

  $rect <750,310,950,350>
  slot OnDragM
  {
    var point delta = SimpleTouchHandlerM.CurrentPos - SimpleTouchHandlerM.HittingPos;

    /* as soon as the user has moved the finger a little bit - pass the touch events
       to the slide touch handler */
    if (( delta.y > 8 ) || ( delta.y < -8 ))
    {
      GetRoot().DeflectCursor( SlideTouchHandlerM, <0,0> );
      SimpleTouchHandlerM.Enabled = false;
    }
  }

  $rect <750,270,950,310>
  slot OnReleaseM
  {
    /* ff the user has just tapped the simple touch handler without sliding, directly select the item */
    if ( !SimpleTouchHandlerM.AutoDeflected && TopListM.Opacity == 0xFF )
    {
      var int32 delta = 0;

      /* calculate the offset in number of items */
      if ( SimpleTouchHandlerM.CurrentPos.y < MainListM.Bounds.y1 )
        delta = ( SimpleTouchHandlerM.CurrentPos.y - MainListM.Bounds.y1 ) / TopListM.ItemHeight - 1;
      else if ( SimpleTouchHandlerM.CurrentPos.y > MainListM.Bounds.y2 )
        delta = ( SimpleTouchHandlerM.CurrentPos.y - MainListM.Bounds.y2 ) / BottomListM.ItemHeight + 1;

      if ( delta != 0 )
      {
        var int32 item = -MainListM.ScrollOffset / MainListM.ItemHeight + delta;
        MainListM.EnsureVisible( item, true, Int32EffectM, null );
      }
    }
    /* don't forget to start the fade out */
    signal OnEnd;

  }

  $rect <950,270,1150,310>
  object Effects::Int32Effect Int32EffectM
  {
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
  }

  // The class 'TimeList' implements a special type of list to display an hour value \
  // and a minute value, both with a magnification effect of the middle item. For \
  // this purpose, three different vertical lists are used for each side (hour and \
  // minute): A top list with small items, a center list with large items and a bottom \
  // list with small items. The three lists are synchronized, so that it appears \
  // for the user as one list. In order to make the list widget more attractive, \
  // the top and bottom lists are connected with a fade-in/fade-out effect: As soon \
  // as the user touches the widget, the text item dissappears, and the top/bottom \
  // lists start to fade-in. After a certain idle time, the top/bottom lists will \
  // fade-out.
  note legend Note
  {
    attr Bounds = <350,410,1150,550>;
  }
}

// This is a GUI component.
$rect <240,300,440,340>
$output false
class HourItemL : Core::Group
{
  $rect <0,270,200,310>
  inherited property Bounds = <0,0,165,240>;

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,150,240>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "00";
    preset Font = Washer::ListFontXL;
    preset Color = Washer::ButtonTextColor;
  }

  // The property 'Caption' contains the text of the list item.
  $rect <250,0,450,40>
  property string Caption = "";

  $rect <250,40,450,80>
  onset Caption
  {
    pure Caption = value;
    Text.String = value;
  }
}

// This is a GUI component.
$rect <440,300,640,340>
$output false
class MinItemL : Core::Group
{
  $rect <0,260,200,300>
  inherited property Bounds = <0,0,165,240>;

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <20,0,165,240>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "00";
    preset Font = Washer::ListFontXL;
    preset Color = Washer::ButtonTextColor;
  }

  // The property 'Caption' contains the text of the list item.
  $rect <250,0,450,40>
  property string Caption = "";

  $rect <250,40,450,80>
  onset Caption
  {
    pure Caption = value;
    Text.String = value;
  }
}

// This is a GUI component.
$rect <440,340,640,380>
$output false
class MinItemS : Core::Group
{
  $rect <0,190,200,230>
  inherited property Bounds = <0,0,165,60>;

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Back
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,165,60>;
    preset Color = Washer::ListBgColor;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Center
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <0,0,1,60>;
    preset Color = Washer::ButtonTextColor;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Right
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <162,0,165,60>;
    preset Color = Washer::ListBgColor;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,165,60>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Text";
    preset Font = Washer::ListFontS;
    preset Color = Washer::ListTextColor;
  }

  // The property 'Caption' contains the text of the list item.
  $rect <250,0,450,40>
  property string Caption = "";

  $rect <250,40,450,80>
  onset Caption
  {
    pure Caption = value;
    Text.String = value;
  }
}

// This is a bitmap resource.
$rect <890,390,1090,430>
$output false
resource Resources::Bitmap BgHot
{
  attr bitmapfile FileName = .\Res\Hot.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// This is a bitmap resource.
$rect <890,430,1090,470>
$output false
resource Resources::Bitmap BgDelicates
{
  attr bitmapfile FileName = .\Res\Delicates.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// This is a bitmap resource.
$rect <890,470,1090,510>
$output false
resource Resources::Bitmap BgSportswear
{
  attr bitmapfile FileName = .\Res\Sportswear.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// This is a bitmap resource.
$rect <890,510,1090,550>
$output false
resource Resources::Bitmap BgWool
{
  attr bitmapfile FileName = .\Res\Wool.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// This is a bitmap resource.
$rect <890,550,1090,590>
$output false
resource Resources::Bitmap BgEco
{
  attr bitmapfile FileName = .\Res\Eco.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// Color constant according UI design.
$rect <1090,40,1290,80>
$output false
const color TempColor0 = #2A7394FF;

// Color constant according UI design.
$rect <1090,120,1290,160>
$output false
const color TempColor2 = #BCE43FFF;

// Color constant according UI design.
$rect <1090,160,1290,200>
$output false
const color TempColor3 = #FDFD34FF;

// Color constant according UI design.
$rect <1090,200,1290,240>
$output false
const color TempColor4 = #FEC12BFF;

// Color constant according UI design.
$rect <1090,240,1290,280>
$output false
const color TempColor5 = #FD5521FF;

// Color constant according UI design.
$rect <1090,280,1290,320>
$output false
const color TempColor6 = #FD1A1FFF;

// Color constant according UI design.
$rect <1090,80,1290,120>
$output false
const color TempColor1 = #67A56CFF;

// This is a bitmap resource.
$rect <1090,510,1290,550>
$output false
resource Resources::Bitmap Shadow
{
  attr bitmapfile FileName = .\Res\Shadow.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// This is a GUI component.
$rect <240,40,440,80>
$output false
class StartButton : Core::Group
{
  $rect <10,190,210,230>
  inherited property Bounds = <0,0,360,120>;

  $rect <10,140,210,180>
  inherited method UpdateViewState()
  {
    aState;

    /* colorize background if currently selected */
    if ( TouchHandler.Down && TouchHandler.Inside )
      Background.Color = Washer::StopColor;
    else 
      Background.Color = Washer::StartColor;

  }

  // This is a bitmap frame view.
  $rect <20,20,160,60>
  object Views::Frame Frame
  {
    preset Bounds = <0,0,240,80>;
    preset Color = #00000080;
    preset Edges = Graphics::Edges[Bottom, Left, Right, Top];
    preset Bitmap = Washer::Shadow;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,90>;
    preset Point3 = <330,90>;
    preset Point2 = <330,0>;
    preset Point1 = <0,0>;
    preset OnLeave = enterLeaveSlot;
    preset OnEnter = enterLeaveSlot;
    preset OnRelease = pressReleaseSlot;
    preset OnPress = pressReleaseSlot;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,330,90>;
    preset Color = #FFB65FFF;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,330,90>;
    preset String = "START";
    preset Font = Washer::ListFontM;
  }

  // This internal slot method is used to receive the corresponding signals form \
  // the touch handler.
  $rect <380,10,580,50>
  slot enterLeaveSlot
  {
    InvalidateViewState();
  }

  // This internal slot method is used to receive the corresponding signals form \
  // the touch handler.
  $rect <380,50,580,90>
  slot pressReleaseSlot
  {
    /* releasing the finger outside the button area is ignored */
    if ( !TouchHandler.Down && TouchHandler.Inside )
    {
      /* inform the OnChange slot method */
      signal OnChange;
    }
  }

  // The property 'OnChange' can refer to a slot method, which will receive a signal \
  // as soon the user has pressed the button. Thereupon the method's logic will be \
  // executed.
  $rect <580,50,780,90>
  property slot OnChange = null;
}

// Color constant according UI design.
$rect <890,240,1090,280>
$output false
const color StartColor = #8BD136FF;

// Color constant according UI design.
$rect <890,280,1090,320>
$output false
const color StopColor = #D13B00FF;

// This is a bitmap resource.
$rect <1090,390,1290,430>
$output false
resource Resources::Bitmap BgSpin
{
  attr bitmapfile FileName = .\Res\Spin.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// This is a bitmap resource.
$rect <1090,430,1290,470>
$output false
resource Resources::Bitmap BgDrain
{
  attr bitmapfile FileName = .\Res\Drain.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// This is a bitmap resource.
$rect <1090,470,1290,510>
$output false
resource Resources::Bitmap BgEasyCare
{
  attr bitmapfile FileName = .\Res\EasyCare.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// List item classes and list classes
note group Note
{
  attr Bounds = <20,110,660,440>;
}

// Time and color constants
note group Note1
{
  attr Bounds = <670,0,1310,340>;
}

// Resources
note group Note2
{
  attr Bounds = <670,350,1310,610>;
}

// Device class
note group Note3
{
  attr Bounds = <20,450,660,550>;
}

// Washing machine main screen and start button
note group Note4
{
  attr Bounds = <20,0,660,100>;
}
